module src/games/tango

import src/util/gamegrid
import src/util/vec2i
import src/util/randomutil
import src/util/gamestate
import src/util/connection

import random
import test
import array
import control
import tty

// TODO: Decide for s = status or c = cell as parameters

type Cell {
  Moon();
  Sun();
  Empty();
}

def isEmptyCell(c: Cell): Bool / {} = {
  c match {
    case Empty() => true
    case _ => false
  }
}

def equals(a: Cell, b: Cell): Bool / {} = {
  (a, b) match {
    case (Moon(), Moon()) => true
    case (Sun(), Sun()) => true
    case (Empty(), Empty()) => true
    case _ => false
  }
}

def infixEq(a: Cell, b: Cell): Bool / {} = {
  a.equals(b)
}

def show(c: Cell): String / {} = {
  c match {
    case Moon() => "â¾"
    case Sun() => "ð–¤“"
    case Empty() => "."
  }
}

type Board = Gamegrid[Cell] // TODO: Maybe use Cell record? If not, change in zip

type ConstraintType {
  Equal();
  Diff();
}

def equals(a: ConstraintType, b: ConstraintType): Bool / {} = {
  (a, b) match {
    case (Equal(), Equal()) => true
    case (Diff(), Diff()) => true
    case _ => false
  }
}

def show(constr: ConstraintType): String / {} = {
  constr match {
    case Equal() => "="
    case Diff() => "x"
  }
}

type Constraint = Connection[ConstraintType]
def Constraint(u: Vec2i, v: Vec2i, typ: ConstraintType) = Connection(u, v, typ) // TODO: Is this necessary??

def satisfies(board: Board, constr: Constraint): Bool / {} = {
  constr.typ match {
    case Equal() => equals(board.get(constr.from), board.get(constr.to))
    case Diff() => not(equals(board.get(constr.from), board.get(constr.to)))
  }
}

interface Search {
  def pickSymbol(v: (Int, Int)): Cell
  def fail(): Nothing
}

def placeAllSymbolCombinations(board: Board): List[Board] / {} = {
  try {
    var new_board = board.copy()

    [0,1,2,3,4,5].foreach {col =>
      [0,1,2,3,4,5].foreach {row =>
        val symbol = do pickSymbol((col, row))

        if(new_board.isValidPlacement((col, row), symbol)) {
          new_board = new_board.setCopy((col, row), symbol)
        }
        else {
          do fail()
        }
      }
    }

    [new_board]

  } with Search {
    def pickSymbol(v) = {
      resume(Moon()).append(resume(Sun()))
    }

    def fail() = {[]}
  }
}

def placeOneSymbolCombination(board: Board): Board / {random, Exception[MissingValue]} = {
  try {
    var new_board = board.copy()

    [0,1,2,3,4,5].foreach {col =>
      [0,1,2,3,4,5].foreach {row =>
        val symbol = do pickSymbol((col, row))

        if(new_board.isValidPlacement((col, row), symbol)) {
          new_board = new_board.setCopy((col, row), symbol)
        }
        else {
          do fail()
        }
      }
    }

    Some(new_board)

  } with Search {
    def pickSymbol(v) = {
      var o_board: Option[Board] = None()

      [Moon(), Sun()].shuffle().foreach{(s) {l: Label} =>
        resume(s) match {
          case Some(b) => {
            o_board = Some(b)
            l.break()
          }
          case None() => l.continue()
        }
      }

      o_board
    }

    def fail() = {None()}
  }
  .value
}

def generateGame(): Board / {random} = {
  var board = gamegrid::init(6, 6, Empty())

  with on[MissingValue].panic()
  board = board.placeOneSymbolCombination()

  board
}

// TODO: Refactor
def threeInARow(board: Board, row: Int): Bool / {} = {
  var last_symbol = Empty()
  var n_repeating = 0

  var tree_in_a_row = false

  board.horizontalCellsOf(row).foreach {(s) {l: Label} =>
    if(n_repeating == 3) {
      tree_in_a_row = true
      l.break()
    }

    s match {

      case Moon() => {
        if (last_symbol == Moon()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Moon()
        }
      }

      case Sun() => {
        if (last_symbol == Sun()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Sun()
        }
      }

      case Empty() => {
        n_repeating = 0
        last_symbol = Empty()
      }
    }
  }

  tree_in_a_row
}

// TODO: Refactor
def threeInACol(board: Board, col: Int): Bool / {} = {
  var last_symbol = Empty()
  var n_repeating = 0

  var tree_in_a_col = false

  board.verticalCellsOf(col).foreach {(s) {l: Label} =>
    if(n_repeating == 3) {
      tree_in_a_col = true
      l.break()
    }

    s match {

      case Moon() => {
        if (last_symbol == Moon()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Moon()
        }
      }

      case Sun() => {
        if (last_symbol == Sun()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Sun()
        }
      }

      case Empty() => {
        n_repeating = 0
        last_symbol = Empty()
      }
    }
  }

  tree_in_a_col
}

// TODO: Check constraints
// TODO: Refactor
// TODO: Improve
def isValidPlacement(board: Board, v: Vec2i, c: Cell): Bool / {} = {
  // Checking all vertical cells how many symbols there are
  var vert_num_suns = board.verticalCellsExcluding(v).count {c => c.equals(Sun())}
  var vert_num_moons = board.verticalCellsExcluding(v).count {c => c.equals(Moon())}

  // Checking all horizontal cells how many symbols there are
  var horiz_num_suns = board.horizontalCellsExcluding(v).count {c => c.equals(Sun())}
  var horiz_num_moons = board.horizontalCellsExcluding(v).count {c => c.equals(Moon())}

  // Adding the symbol that would be placed
  c match {
    case Moon() => {vert_num_moons = vert_num_moons + 1
                    horiz_num_moons = horiz_num_moons + 1}
    case Sun() => {vert_num_suns = vert_num_suns + 1
                    horiz_num_suns = horiz_num_suns + 1}
    case _ => ()
  }

  val new_board = board.setCopy(v, c)

  vert_num_moons <= 3 && horiz_num_moons <= 3 &&
  vert_num_suns <= 3 && horiz_num_suns <= 3 &&
  not(new_board.threeInACol(v.x)) && not(new_board.threeInARow(v.y))
}

// TODO: Improve performance
def isWinning(board: Board, constraints: List[Constraint]): Bool / {} = {
  var isValid = true

  // Checking about number of moons and suns
  [0,1,2,3,4,5].foreach {(c) {l: Label} =>
    val num_suns = board.verticalCellsOf(c).count {c => c.equals(Sun())}
    val num_moons = board.verticalCellsOf(c).count {c => c.equals(Moon())}
    val num_empty = board.verticalCellsOf(c).count {c => c.equals(Empty())}

    if(num_suns != 3 || num_moons != 3 || num_empty > 0) {
      isValid = false
      l.break()
    }
  }

  // Checking for 3 in a col
  [0,1,2,3,4,5].foreach {(c) {l: Label} =>
    if(board.threeInACol(c)) {
      isValid = false
      l.break()
    }
  }

  // Checking for 3 in a row
  [0,1,2,3,4,5].foreach {(r) {l: Label} =>
    if(board.threeInARow(r)) {
      isValid = false
      l.break()
    }
  }

  // Checking if all constraints match
  constraints.foreach {(constr) {l: Label} =>
    if(not(board.satisfies(constr))) {
      isValid = false
      l.break()
    }
  }

  isValid
}

def showBoard(board: Board, cursor: Vec2i, constraints: List[Constraint]): Gamegrid[String] / {} = {

  def transformConstraint(constr: Constraint): (Vec2i, Vec2i, String) / {} = {
    (constr.from, constr.to, show(constr.typ))
  }

  val connections = constraints.map {transformConstraint }

  board.mapWithIndex {(v, s) =>
    if (v == cursor) {
      Escape::BLINK ++ show(s) ++ Escape::RESET
    }
    else {
      show(s)
    }
  }.extendGridBy1Connecting(" ", connections)
}

def gameloop(board: Board, constraints: List[Constraint]): Unit / {Gamestate[Cell, ConstraintType]} = {
  var cursor = (0, 0)
  var current_board = board

  val input_options = [
    InputOption("w", "Cursor up"),
    InputOption("s", "Cursor down"),
    InputOption("a", "Cursor left"),
    InputOption("d", "Cursor right"),
    InputOption("t", "Place ð–¤“"),
    InputOption("n", "Place â¾"),
    InputOption("x", "Reset cell"),
  ]

  loop() {{l: Label} =>
    // Sending current board to console
    do updateGrid(current_board, showBoard(current_board, cursor, constraints), constraints)

    if(current_board.isWinning(constraints)) {
      l.break()
    }

    val input = do getUserInput(input_options)

    input match {
      case "w" => cursor = cursor.addOntoIfInBound((0,-1), current_board)
      case "a" => cursor = cursor.addOntoIfInBound((-1,0), current_board)
      case "s" => cursor = cursor.addOntoIfInBound((0,1), current_board)
      case "d" => cursor = cursor.addOntoIfInBound((1,0), current_board)
      case "t" => current_board.set(cursor, Sun())
      case "n" => current_board.set(cursor, Moon())
      case "x" => current_board.set(cursor, Empty())
      case _ => l.continue()
    }
  }

  do gameWon(
    """
 __     __                                 _______                        _
 \ \   / /                                |__   __|                      | |
  \ \_/ /__  _   _  __      _____  _ __      | | __ _ _ __   __ _  ___   | |
   \   / _ \| | | | \ \ /\ / / _ \| '_ \     | |/ _` | '_ \ / _` |/ _ \  | |
    | | (_) | |_| |  \ V  V / (_) | | | |    | | (_| | | | | (_| | (_) | |_|
    |_|\___/ \__,_|   \_/\_/ \___/|_| |_|    |_|\__,_|_| |_|\__, |\___/  (_)
                                                             __/ |
                                                            |___/

    """
    )
}

def hideSymbols(board: Board, symbol_keep_factor: Double): Board / {random} = {
  board.map{s =>
    var new_symbol = s
    bernoulli(symbol_keep_factor)
    {
      () // we keep the symbol
    }
    {
      new_symbol = Empty() // we hide the symbol (make it Empty)
    }
    new_symbol
  }
}

def hideConstraints(constraints: List[Constraint], keep_factor: Double): List[Constraint] / {random} = {
  var new_constraints: List[Constraint] = []

  constraints.foreach {v =>
    bernoulli(keep_factor)
    {
      new_constraints = Cons(v, new_constraints)
    }
    {
      () // In case of 1 - keep_factor, we dont take this constraint into the new_constraints
    }
  }

  new_constraints
}

// TODO: Test
// TODO: Refactor, maybe use sets
def generateAllConstraints(board: Board): List[Constraint] / {} = {
  var constraints: List[Constraint] = []

  board.grid.foreachIndex {(i, s) =>
    val v = indexToCoords(i, board.width)
    board.surroundingCells4WithIndices(v).foreach {t =>
      val u = t.first // coords of neighbour
      val n = t.second // symbol of neighour

      if(n == s) { // if the neighbour is the same symbol
        val c = Constraint(v, u, Equal())

        if (not(constraints.contains(c) { (a,b) => connection::equals(a, b) })) {
          constraints = Cons(c, constraints)
        }
      }
      else { // if the neighbour is a different symbol
        val c = Constraint(v, u, Diff())

        if (not(constraints.contains(c) { (a,b) => connection::equals(a, b) })) {
          constraints = Cons(c, constraints)
        }
      }
    }
  }

  constraints
}

def playGame(symbol_keep_factor: Double, constraint_keep_factor: Double): Unit / {random, Gamestate[Cell, ConstraintType]} = {
  with on[RuntimeError].panic();

  var board = generateGame()
  var constraints = generateAllConstraints(board)

  board = board.hideSymbols(symbol_keep_factor)
  constraints = constraints.hideConstraints(constraint_keep_factor)

  gameloop(board, constraints)
}

def testSuite(): Bool = suite("games/tango") {

  test("isWinningNoConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    assertTrue(b.isWinning([]))
  }

  test("isNotWinningNoConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Moon(), Moon(), Sun(), Moon(), Sun(), // One moon too many
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    assertFalse(b.isWinning([]))
  }

  test("isWinningWithConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    val constraints = [Constraint((0,0), (1,0), Diff()),
                       Constraint((0, 1), (0, 2), Equal()),
                       Constraint((5, 0), (5, 1), Equal())]

    assertTrue(b.isWinning(constraints))
  }

  test("isNotWinningWithConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    val constraints = [Constraint((0,1), (0,2), Diff()), // Is not satisfied
                       Constraint((5, 0), (5, 1), Equal())]

    assertFalse(b.isWinning(constraints))
  }

  test("isNotWinning3AfterAnother") {
    val b = Gamegrid(6, 6, fromList([Moon(), Moon(), Moon(), Sun(), Sun(), Sun(), // Is not valid since 3 in a row
                                     Moon(), Moon(), Moon(), Sun(), Sun(), Sun(),
                                     Moon(), Moon(), Moon(), Sun(), Sun(), Sun(),
                                     Sun(), Sun(), Sun(), Moon(), Moon(), Moon(),
                                     Sun(), Sun(), Sun(), Moon(), Moon(), Moon(),
                                     Sun(), Sun(), Sun(), Moon(), Moon(), Moon()]))

    assertFalse(b.isWinning([]))
  }

  test("isValidPlacement") {
    val b = gamegrid::init(6, 6, Empty())

    assertTrue(b.isValidPlacement((1, 1), Moon()))
  }

  test("isNotValidPlacement") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(), // placing Moon to (0, 1)
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    assertFalse(b.isValidPlacement((0, 1), Moon()))
  }

  test("isNotValidPlacement3AfterAnother") {
    val b = Gamegrid(6, 6, fromList([Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(), // Is not valid since 3 in a row
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))

    assertFalse(b.isValidPlacement((0, 3), Moon()))
  }

  test("allGamesValid") {
    val b = gamegrid::init(6, 6, Empty())
    val all_boards = placeAllSymbolCombinations(b)

    assertTrue(all_boards.all {b => b.isWinning([])})
  }

  test("constraintEquals") {
    val a = Constraint((1, 0), (0, 1), Equal())
    val b = Constraint((1, 0), (0, 1), Equal())
  }

  test("constraintEquals2") {
    val a = Constraint((1, 0), (0, 1), Equal())
    val b = Constraint((0, 1), (1, 0), Equal())
  }

  test("constraintNotEquals") {
    val a = Constraint((1, 0), (1, 0), Equal())
    val b = Constraint((1, 0), (1, 0), Diff())
  }

  test("threeInACol") {
    val b = Gamegrid(6, 6, fromList([Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))
    assertTrue(b.threeInACol(0))
  }

  test("notThreeInACol") {
    val b = Gamegrid(6, 6, fromList([Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))
    assertFalse(b.threeInACol(0))
  }

  test("threeInAColEmpty") {
    val b = Gamegrid(6, 6, fromList([Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))
    assertFalse(b.threeInACol(1))
  }

  test("threeInARow") {
    val b = Gamegrid(6, 6, fromList([Empty(), Moon(), Moon(), Moon(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))
    assertTrue(b.threeInARow(0))
  }

  test("notThreeInARow") {
    val b = Gamegrid(6, 6, fromList([Empty(), Moon(), Moon(), Sun(), Moon(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))
    assertFalse(b.threeInARow(0))
  }
}