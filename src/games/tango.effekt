module src/games/tango

import src/util/gamegrid
import src/util/vec2i
import src/util/randomutil
import src/util/gamestate
import src/util/connection

import random
import test
import array
import control
import io/console
import io/time
import tty

// TODO: Decide for s = status or c = cell as parameters

type Cell {
  Moon();
  Sun();
  Empty();
}

def isEmptyCell(c: Cell): Bool / {} = {
  c match {
    case Empty() => true
    case _ => false
  }
}

def equals(a: Cell, b: Cell): Bool / {} = {
  (a, b) match {
    case (Moon(), Moon()) => true
    case (Sun(), Sun()) => true
    case (Empty(), Empty()) => true
    case _ => false
  }
}

def infixEq(a: Cell, b: Cell): Bool / {} = {
  a.equals(b)
}

// TODO: Add colors
def show(c: Cell): String / {} = {
  c match {
    case Moon() => "\u001b[34m" ++ "â¾" ++ Escape::RESET
    case Sun() => "\u001b[33m" ++ "ð–¤“" ++ Escape::RESET
    case Empty() => "."
  }
}

type Board = Gamegrid[Cell] // TODO: Maybe use Cell record? If not, change in zip

type ConstraintType {
  Equal();
  Diff();
}

def equals(a: ConstraintType, b: ConstraintType): Bool / {} = {
  (a, b) match {
    case (Equal(), Equal()) => true
    case (Diff(), Diff()) => true
    case _ => false
  }
}

def show(constr: ConstraintType): String / {} = {
  constr match {
    case Equal() => "="
    case Diff() => "x"
  }
}

type Constraint = Connection[ConstraintType]
def Constraint(u: Vec2i, v: Vec2i, typ: ConstraintType) = Connection(u, v, typ) // TODO: Is this necessary??

def satisfies(board: Board, constr: Constraint): Bool / {} = {
  val a = board.get(constr.from)
  val b = board.get(constr.to)

  constr.typ match {
    case Equal() => equals(a, b)
    case Diff() => not(equals(a, b))
  }
}

// This can be used when there are still empty cells, but we want to place something. Here, empty = Moon is ok (or Moon x Empty)
def weakSatisfies(board: Board, constr: Constraint): Bool / {} = {
  val a = board.get(constr.from)
  val b = board.get(constr.to)

  (a == Empty() || b == Empty()) || // either can be Empty
  (constr.typ match {
    case Equal() => equals(a, b)
    case Diff() => not(equals(a, b))
  })
}

val INPUT_OPTIONS = [
  InputOption("w", "Cursor up"),
  InputOption("s", "Cursor down"),
  InputOption("a", "Cursor left"),
  InputOption("d", "Cursor right"),
  InputOption("t", "Place ð–¤“"),
  InputOption("n", "Place â¾"),
  InputOption("x", "Reset cell"),
]

// TODO: Remove
def inputOptionToOffset(i: InputOption): Vec2i / {} = {
  i.key match {
    case "w" => (0, -1)
    case "s" => (0, 1)
    case "a" => (-1, 0)
    case "d" => (0, 1)
    case _ => (0, 0) // TODO: Find default
  }
}

interface Search {
  def pickSymbol(v: (Int, Int)): Cell
  def fail(): Nothing
}

def placeAllSymbolCombinations(board: Board): List[Board] / {} = {
  try {
    var new_board = board.copy()

    [0,1,2,3,4,5].foreach {col =>
      [0,1,2,3,4,5].foreach {row =>
        val symbol = do pickSymbol((col, row))

        if(new_board.isValidPlacement((col, row), symbol, [])) { // TODO: Check if real constraints here
          new_board = new_board.setCopy((col, row), symbol)
        }
        else {
          do fail()
        }
      }
    }

    [new_board]

  } with Search {
    def pickSymbol(v) = {
      resume(Moon()).append(resume(Sun()))
    }

    def fail() = {[]}
  }
}

def placeOneSymbolCombination(board: Board): Board / {random, Exception[MissingValue]} = {
  try {
    var new_board = board.copy()

    [0,1,2,3,4,5].foreach {col =>
      [0,1,2,3,4,5].foreach {row =>
        val symbol = do pickSymbol((col, row))

        if(new_board.isValidPlacement((col, row), symbol, [])) { // TODO: Check if real constraints here
          new_board = new_board.setCopy((col, row), symbol)
        }
        else {
          do fail()
        }
      }
    }

    Some(new_board)

  } with Search {
    def pickSymbol(v) = {
      var o_board: Option[Board] = None()

      [Moon(), Sun()].shuffle().foreach{(s) {l: Label} =>
        resume(s) match {
          case Some(b) => {
            o_board = Some(b)
            l.break()
          }
          case None() => l.continue()
        }
      }

      o_board
    }

    def fail() = {None()}
  }
  .value
}

def generateGame(): Board / {random} = {
  var board = gamegrid::init(6, 6, Empty())

  with on[MissingValue].panic()
  board = board.placeOneSymbolCombination()

  board
}

// TODO: Refactor
def threeInARow(board: Board, row: Int): Bool / {} = {
  var last_symbol = Empty()
  var n_repeating = 0

  var tree_in_a_row = false

  board.horizontalCellsOf(row).foreach {(s) {l: Label} =>
    if(n_repeating == 3) {
      tree_in_a_row = true
      l.break()
    }

    s match {

      case Moon() => {
        if (last_symbol == Moon()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Moon()
        }
      }

      case Sun() => {
        if (last_symbol == Sun()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Sun()
        }
      }

      case Empty() => {
        n_repeating = 0
        last_symbol = Empty()
      }
    }
  }

  tree_in_a_row
}

// TODO: Refactor
def threeInACol(board: Board, col: Int): Bool / {} = {
  var last_symbol = Empty()
  var n_repeating = 0

  var tree_in_a_col = false

  board.verticalCellsOf(col).foreach {(s) {l: Label} =>
    if(n_repeating == 3) {
      tree_in_a_col = true
      l.break()
    }

    s match {

      case Moon() => {
        if (last_symbol == Moon()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Moon()
        }
      }

      case Sun() => {
        if (last_symbol == Sun()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Sun()
        }
      }

      case Empty() => {
        n_repeating = 0
        last_symbol = Empty()
      }
    }
  }

  tree_in_a_col
}

// TODO: Check constraints
// TODO: Refactor
// TODO: Improve
def isValidPlacement(board: Board, v: Vec2i, c: Cell, constraints: List[Constraint]): Bool / {} = {
  // Checking all vertical cells how many symbols there are
  var vert_num_suns = board.verticalCellsExcluding(v).count {c => c.equals(Sun())}
  var vert_num_moons = board.verticalCellsExcluding(v).count {c => c.equals(Moon())}

  // Checking all horizontal cells how many symbols there are
  var horiz_num_suns = board.horizontalCellsExcluding(v).count {c => c.equals(Sun())}
  var horiz_num_moons = board.horizontalCellsExcluding(v).count {c => c.equals(Moon())}

  // Adding the symbol that would be placed
  c match {
    case Moon() => {vert_num_moons = vert_num_moons + 1
                    horiz_num_moons = horiz_num_moons + 1}
    case Sun() => {vert_num_suns = vert_num_suns + 1
                    horiz_num_suns = horiz_num_suns + 1}
    case _ => ()
  }

  val new_board = board.setCopy(v, c)

  vert_num_moons <= 3 && horiz_num_moons <= 3 &&
  vert_num_suns <= 3 && horiz_num_suns <= 3 &&
  not(new_board.threeInACol(v.x)) &&
  not(new_board.threeInARow(v.y)) &&
  constraints.all {constr => new_board.weakSatisfies(constr)}
}

// TODO: Improve performance
def isWinning(board: Board, constraints: List[Constraint]): Bool / {} = {
  var isValid = true

  // Checking about number of moons and suns
  [0,1,2,3,4,5].foreach {(c) {l: Label} =>
    val num_suns = board.verticalCellsOf(c).count {c => c.equals(Sun())}
    val num_moons = board.verticalCellsOf(c).count {c => c.equals(Moon())}
    val num_empty = board.verticalCellsOf(c).count {c => c.equals(Empty())}

    if(num_suns != 3 || num_moons != 3 || num_empty > 0) {
      isValid = false
      l.break()
    }
  }

  // Checking for 3 in a col
  [0,1,2,3,4,5].foreach {(c) {l: Label} =>
    if(board.threeInACol(c)) {
      isValid = false
      l.break()
    }
  }

  // Checking for 3 in a row
  [0,1,2,3,4,5].foreach {(r) {l: Label} =>
    if(board.threeInARow(r)) {
      isValid = false
      l.break()
    }
  }

  // Checking if all constraints match
  constraints.foreach {(constr) {l: Label} =>
    if(not(board.satisfies(constr))) {
      isValid = false
      l.break()
    }
  }

  isValid
}

def showBoard(board: Board, cursor: Vec2i, constraints: List[Constraint]): Gamegrid[String] / {} = {

  def transformConstraint(constr: Constraint): (Vec2i, Vec2i, String) / {} = {
    (constr.from, constr.to, show(constr.typ))
  }

  val connections = constraints.map {transformConstraint }

  board.mapWithIndex {(v, s) =>
    if (v == cursor) {
      Escape::BLINK ++ show(s) ++ Escape::RESET
    }
    else {
      show(s)
    }
  }.extendGridBy1Connecting(" ", connections)
}

def gameloop(board: Board, constraints: List[Constraint]): Unit / {Gamestate[Cell, ConstraintType]} = {
  var cursor = (0, 0)
  var current_board = board

  loop() {{l: Label} =>
    // Sending current board to console
    do updateGrid(current_board, showBoard(current_board, cursor, constraints), constraints)

    if(current_board.isWinning(constraints)) {
      l.break()
    }

    val input = do getUserInput(INPUT_OPTIONS)

    input match {
      case "w" => cursor = cursor.addOntoIfInBound((0,-1), current_board)
      case "a" => cursor = cursor.addOntoIfInBound((-1,0), current_board)
      case "s" => cursor = cursor.addOntoIfInBound((0,1), current_board)
      case "d" => cursor = cursor.addOntoIfInBound((1,0), current_board)
      case "t" => current_board.set(cursor, Sun())
      case "n" => current_board.set(cursor, Moon())
      case "x" => current_board.set(cursor, Empty())
      case _ => l.continue()
    }
  }

  do gameWon(
    """
 __     __                                 _______                        _
 \ \   / /                                |__   __|                      | |
  \ \_/ /__  _   _  __      _____  _ __      | | __ _ _ __   __ _  ___   | |
   \   / _ \| | | | \ \ /\ / / _ \| '_ \     | |/ _` | '_ \ / _` |/ _ \  | |
    | | (_) | |_| |  \ V  V / (_) | | | |    | | (_| | | | | (_| | (_) | |_|
    |_|\___/ \__,_|   \_/\_/ \___/|_| |_|    |_|\__,_|_| |_|\__, |\___/  (_)
                                                             __/ |
                                                            |___/

    """
    )
}

def hideSymbols(board: Board, symbol_keep_factor: Double): Board / {random} = {
  board.map{s =>
    var new_symbol = s
    bernoulli(symbol_keep_factor)
    {
      () // we keep the symbol
    }
    {
      new_symbol = Empty() // we hide the symbol (make it Empty)
    }
    new_symbol
  }
}

def hideConstraints(constraints: List[Constraint], keep_factor: Double): List[Constraint] / {random} = {
  var new_constraints: List[Constraint] = []

  constraints.foreach {v =>
    bernoulli(keep_factor)
    {
      new_constraints = Cons(v, new_constraints)
    }
    {
      () // In case of 1 - keep_factor, we dont take this constraint into the new_constraints
    }
  }

  new_constraints
}

// TODO: Test
// TODO: Refactor, maybe use sets
def generateAllConstraints(board: Board): List[Constraint] / {} = {
  var constraints: List[Constraint] = []

  board.grid.foreachIndex {(i, s) =>
    val v = indexToCoords(i, board.width)
    board.surroundingCells4WithIndices(v).foreach {t =>
      val u = t.first // coords of neighbour
      val n = t.second // symbol of neighour

      if(n == s) { // if the neighbour is the same symbol
        val c = Constraint(v, u, Equal())

        if (not(constraints.contains(c) { (a,b) => connection::equals(a, b) })) {
          constraints = Cons(c, constraints)
        }
      }
      else { // if the neighbour is a different symbol
        val c = Constraint(v, u, Diff())

        if (not(constraints.contains(c) { (a,b) => connection::equals(a, b) })) {
          constraints = Cons(c, constraints)
        }
      }
    }
  }

  constraints
}

def playGame(symbol_keep_factor: Double, constraint_keep_factor: Double): Unit / {random, Gamestate[Cell, ConstraintType]} = {
  with on[RuntimeError].panic();

  var board = generateGame()
  var constraints = generateAllConstraints(board)

  board = board.hideSymbols(symbol_keep_factor)
  constraints = constraints.hideConstraints(constraint_keep_factor)

  gameloop(board, constraints)
}

// TODO: Test
def applyPlacementsAtOnce(board: Board, placements: List[(Vec2i, Cell)]): Board / {} = {
  var new_board = board.copy()

  placements.foreach {p =>
    val v = p.first
    val s = p.second
    new_board.set(v, s)
  }

  new_board
}

def findPlacementsByBruteForce(board: Board, constraints: List[Constraint]): List[(Vec2i, Cell)] / {} = {

  val empty_cells = board.mapWithIndex {(v, t) => (v, t)}
                         .grid.filtered {t => t.second == Empty()}

  val o_board = try {
    var new_board = board.copy()

    empty_cells.foreach{t =>
        val symbol = do pickSymbol(t.first)

        if(new_board.isValidPlacement(t.first, symbol, constraints)) {
          new_board = new_board.setCopy(t.first, symbol)
        }
        else {
          do fail()
        }
    }

    Some(new_board)

  } with Search {
    def pickSymbol(v) = {
      var o_board: Option[Board] = None()

      [Moon(), Sun()].foreach{(s) {l: Label} =>
        resume(s) match {
          case Some(b) => {
            o_board = Some(b)
            l.break()
          }
          case None() => l.continue()
        }
      }

      o_board
    }

    def fail() = {None()}
  }

  var placements: List[(Vec2i, Cell)] = []

  with on[MissingValue].panic();
  val filled_board = o_board.value

  // Calculating diff between boards := Placements that have to be made
  filled_board.mapWithIndex {(v, s) => (v, s)}.grid.foreach {t =>
    val v = t.first
    val s = t.second

    if(board.get(v) == Empty()) { // if this was empty before
      placements = Cons((v, s), placements) // adding diff to placements
    }
  }

  placements
}

// TODO: Use streams!
def findPlacements(board: Board, constraints: List[Constraint]): List[(Vec2i, Cell)] / {} = {
  var placements: List[(Vec2i, Cell)] = []

  var new_board = board.copy() // TODO: This is unnecessary. At least if update_grid always calculates on new grids

  // Checking all constraints
  def opposite(a: Cell): Cell / {} = {
    a match {
      case Sun() => Moon()
      case Moon() => Sun()
      case Empty() => Empty() // not used
    }
  }

  constraints.foreach{(c) {l: Label} =>
    val a = new_board.get(c.from)
    val b = new_board.get(c.to)

    (a, b, c.typ) match {
      case (Empty(), Empty(), _) => ()

      case (Empty(), s, Equal()) => {placements = Cons((c.from, s), placements)
                                     new_board.set(c.from, s)}
      case (s, Empty(), Equal()) => {placements = Cons((c.to, s), placements)
                                     new_board.set(c.to, s)}

      case (Empty(), s, Diff()) => {placements = Cons((c.from, opposite(s)), placements)
                                    new_board.set(c.from, opposite(s))}
      case (s, Empty(), Diff()) => {placements = Cons((c.to, opposite(s)), placements)
                                    new_board.set(c.to, opposite(s))}

      case _ => () // We dont correct mistakes
    }
  }


  // Checking for 3 in a row/col (not in a row)
  // Checking Colums
  [0,1,2,3,4,5].foreach {col =>
    val vertical_cells = new_board.verticalCellsOf(col)
    val num_moons = vertical_cells.count {s => s == Moon()}
    val num_suns = vertical_cells.count {s => s == Sun()}

    if (num_moons == 3) {
      vertical_cells.foreachIndex{(row, s) =>
        if(s == Empty()) {
          placements = Cons(((col, row), Sun()), placements)
          new_board.set((col, row), Sun())
        }
      }
    }

    if (num_suns == 3) {
      vertical_cells.foreachIndex{(row, s) =>
        if(s == Empty()) {
          placements = Cons(((col, row), Moon()), placements)
          new_board.set((col, row), Moon())
        }
      }
    }
  }

  // Checking Rows
  [0,1,2,3,4,5].foreach {row =>
    val horizon_cells = new_board.horizontalCellsOf(row)
    val num_moons = horizon_cells.count {s => s == Moon()}
    val num_suns = horizon_cells.count {s => s == Sun()}

    if (num_moons == 3) {
      horizon_cells.foreachIndex{(col, s) =>
        if(s == Empty()) {
          placements = Cons(((col, row), Sun()), placements)
          new_board.set((col, row), Sun())
        }
      }
    }

    if (num_suns == 3) {
      horizon_cells.foreachIndex{(col, s) =>
        if(s == Empty()) {
          placements = Cons(((col, row), Moon()), placements)
          new_board.set((col, row), Moon())
        }
      }
    }
  }


  // Iterating rows/cols and check for pairs and gaps
  // Checking columns
  [0,1,2,3,4,5].foreach {col =>
    val vertical_cells = new_board.verticalCellsOf(col)
    var last_2_cells: List[Cell] = [] // This allows us a window of 3 cells over which we can decide

    vertical_cells.foreachIndex{(row, s) =>
      if(last_2_cells.size == 2) {

        s match {

          // -> . ? ?
          case Empty() => {
            last_2_cells match {
              // -> . M M
              case Cons(Moon(), Cons(Moon(), Nil())) => { // 2 in a row
                placements = Cons(((col, row), Sun()), placements)
                new_board.set((col, row), Sun())
              }
              // -> . S S
              case Cons(Sun(), Cons(Sun(), Nil())) => { // 2 in a row
                placements = Cons(((col, row), Moon()), placements)
                new_board.set((col, row), Moon())
              }
              case _ => ()
            }
          }

          // -> M ? ?
          case Moon() => {
            last_2_cells match {
              // -> M . M
              case Cons(Empty(), Cons(Moon(), Nil())) => { // gap
                placements = Cons(((col, row - 1), Sun()), placements)
                new_board.set((col, row - 1), Sun())
              }
              // -> M M .
              case Cons(Moon(), Cons(Empty(), Nil())) => { // 2 in a row (but reverse)
                placements = Cons(((col, row - 2), Sun()), placements)
                new_board.set((col, row - 2), Sun())
              }
              case _ => ()
            }
          }

          // -> M ? ?
          case Sun() => {
            last_2_cells match {
              // -> S . S
              case Cons(Empty(), Cons(Sun(), Nil())) => { // gap
                placements = Cons(((col, row - 1), Moon()), placements)
                new_board.set((col, row - 1), Moon())
              }
              // -> S S .
              case Cons(Sun(), Cons(Empty(), Nil())) => { // 2 in a row (but reverse)
                placements = Cons(((col, row - 2), Moon()), placements)
                new_board.set((col, row - 2), Moon())
              }
              case _ => ()
            }
          }
        }

        last_2_cells = last_2_cells.take(1) // drop the last item
      }

      last_2_cells = Cons(s, last_2_cells)
    }
  }

  // Checking rows
  [0,1,2,3,4,5].foreach {row =>
    val horizon_cells = new_board.horizontalCellsOf(row)
    var last_2_cells: List[Cell] = [] // This allows us a window of 3 cells over which we can decide

    horizon_cells.foreachIndex{(col, s) =>
      if(last_2_cells.size == 2) {

        s match {

          // -> . ? ?
          case Empty() => {
            last_2_cells match {
              // -> . M M
              case Cons(Moon(), Cons(Moon(), Nil())) => { // 2 in a row
                placements = Cons(((col, row), Sun()), placements)
                new_board.set((col, row), Sun())
              }
              // -> . S S
              case Cons(Sun(), Cons(Sun(), Nil())) => { // 2 in a row
                placements = Cons(((col, row), Moon()), placements)
                new_board.set((col, row), Moon())
              }
              case _ => ()
            }
          }

          // -> M ? ?
          case Moon() => {
            last_2_cells match {
              // -> M . M
              case Cons(Empty(), Cons(Moon(), Nil())) => { // gap
                placements = Cons(((col - 1, row), Sun()), placements)
                new_board.set((col - 1, row), Sun())
              }
              // -> M M .
              case Cons(Moon(), Cons(Empty(), Nil())) => { // 2 in a row (but reverse)
                placements = Cons(((col - 2, row), Sun()), placements)
                new_board.set((col - 2, row), Sun())
              }
              case _ => ()
            }
          }

          // -> M ? ?
          case Sun() => {
            last_2_cells match {
              // -> S . S
              case Cons(Empty(), Cons(Sun(), Nil())) => { // gap
                placements = Cons(((col - 1, row), Moon()), placements)
                new_board.set((col - 1, row), Moon())
              }
              // -> S S .
              case Cons(Sun(), Cons(Empty(), Nil())) => { // 2 in a row (but reverse)
                placements = Cons(((col - 2, row), Moon()), placements)
                new_board.set((col - 2, row), Moon())
              }
              case _ => ()
            }
          }
        }

        last_2_cells = last_2_cells.take(1) // drop the last
      }

      last_2_cells = Cons(s, last_2_cells)
    }
  }

  // If after all this ^^^ there is still no placement found, we try all combinations
  if(placements.isEmpty() && (new_board.grid.count {s => s == Empty()}) > 0) {
    placements = findPlacementsByBruteForce(new_board, constraints)
  }

  placements
}

def solve(wait_time: Int) {gameloop: () => Unit / {Gamestate[Cell, ConstraintType]}} = {
  var last_viz_grid: Gamegrid[String] = init(1, 1, "") // Dummy value // TODO: Give function to vizualize the grid..
  var last_grid: Gamegrid[Cell] = init(1, 1, Empty())

  var placements: List[(Vec2i, Cell)] = []

  var cursor = (0, 0)

  with console;
  try {
    gameloop()
  } with Gamestate[Cell, ConstraintType] {

      def getUserInput(allowed) = {
        sleep(wait_time) // better visualization

        if(not(placements.isEmpty)) {
          with on[MissingValue].panic();
          val next_placement = placements.head()
          val target_cursor = next_placement.first

          if(cursor == target_cursor) {
            next_placement.second match {
              case Moon() => {placements = placements.drop(1)
                              resume("n")}
              case Sun() => {placements = placements.drop(1)
                            resume("t")}
              case _ => resume(" ") // TODO: Find default
            }
          }
          else { // Move to correct position
            compareInt(cursor.x, target_cursor.x) match {
              case Less() => {cursor = cursor + (1, 0)
                              resume("d")}
              case Greater() => {cursor = cursor + (-1, 0)
                                resume("a")}
              case _ => compareInt(cursor.y, target_cursor.y) match {
                              case Less() => {cursor = cursor + (0, 1)
                                              resume("s")}
                              case Greater() => {cursor = cursor + (0, -1)
                                                resume("w")}
                              case _ => resume(" ") // we reached the target
              }
            }
          }
        }
      }

      def updateGrid(grid, viz_grid, constraints) = {
        last_grid = grid
        last_viz_grid = viz_grid

        println(Screen::clear())
        println(show(last_viz_grid))

        if(placements.isEmpty) { // TODO: Check for better uninitialized
          placements = findPlacements(last_grid, constraints)
        }

        resume(())
      }

      def gameWon(msg) = {
        println(msg)
      }
  }
}

def testSuite(): Bool = suite("games/tango") {

  test("isWinningNoConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    assertTrue(b.isWinning([]))
  }

  test("isNotWinningNoConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Moon(), Moon(), Sun(), Moon(), Sun(), // One moon too many
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    assertFalse(b.isWinning([]))
  }

  test("isWinningWithConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    val constraints = [Constraint((0,0), (1,0), Diff()),
                       Constraint((0, 1), (0, 2), Equal()),
                       Constraint((5, 0), (5, 1), Equal())]

    assertTrue(b.isWinning(constraints))
  }

  test("isNotWinningWithConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    val constraints = [Constraint((0,1), (0,2), Diff()), // Is not satisfied
                       Constraint((5, 0), (5, 1), Equal())]

    assertFalse(b.isWinning(constraints))
  }

  test("isNotWinning3AfterAnother") {
    val b = Gamegrid(6, 6, fromList([Moon(), Moon(), Moon(), Sun(), Sun(), Sun(), // Is not valid since 3 in a row
                                     Moon(), Moon(), Moon(), Sun(), Sun(), Sun(),
                                     Moon(), Moon(), Moon(), Sun(), Sun(), Sun(),
                                     Sun(), Sun(), Sun(), Moon(), Moon(), Moon(),
                                     Sun(), Sun(), Sun(), Moon(), Moon(), Moon(),
                                     Sun(), Sun(), Sun(), Moon(), Moon(), Moon()]))

    assertFalse(b.isWinning([]))
  }

  test("isValidPlacement") {
    val b = gamegrid::init(6, 6, Empty())

    assertTrue(b.isValidPlacement((1, 1), Moon(), []))
  }

  test("isNotValidPlacement") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(), // placing Moon to (0, 1)
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    assertFalse(b.isValidPlacement((0, 1), Moon(), []))
  }

  test("isNotValidPlacement3AfterAnother") {
    val b = Gamegrid(6, 6, fromList([Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(), // Is not valid since 3 in a row
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))

    assertFalse(b.isValidPlacement((0, 3), Moon(), []))
  }

  test("allGamesValid") {
    val b = gamegrid::init(6, 6, Empty())
    val all_boards = placeAllSymbolCombinations(b)

    assertTrue(all_boards.all {b => b.isWinning([])})
  }

  test("constraintEquals") {
    val a = Constraint((1, 0), (0, 1), Equal())
    val b = Constraint((1, 0), (0, 1), Equal())
  }

  test("constraintEquals2") {
    val a = Constraint((1, 0), (0, 1), Equal())
    val b = Constraint((0, 1), (1, 0), Equal())
  }

  test("constraintNotEquals") {
    val a = Constraint((1, 0), (1, 0), Equal())
    val b = Constraint((1, 0), (1, 0), Diff())
  }

  test("threeInACol") {
    val b = Gamegrid(6, 6, fromList([Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))
    assertTrue(b.threeInACol(0))
  }

  test("notThreeInACol") {
    val b = Gamegrid(6, 6, fromList([Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))
    assertFalse(b.threeInACol(0))
  }

  test("threeInAColEmpty") {
    val b = Gamegrid(6, 6, fromList([Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))
    assertFalse(b.threeInACol(1))
  }

  test("threeInARow") {
    val b = Gamegrid(6, 6, fromList([Empty(), Moon(), Moon(), Moon(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))
    assertTrue(b.threeInARow(0))
  }

  test("notThreeInARow") {
    val b = Gamegrid(6, 6, fromList([Empty(), Moon(), Moon(), Sun(), Moon(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))
    assertFalse(b.threeInARow(0))
  }

  test("findByBruteForce") {
    val b = Gamegrid(6, 6, fromList([Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))

    val placements = b.findPlacementsByBruteForce([])

    val b_new = b.applyPlacementsAtOnce(placements)

    assertTrue(isWinning(b_new, []))
  }
}