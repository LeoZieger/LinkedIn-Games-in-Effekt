module src/games/tango

import src/util/gamegrid
import src/util/vec2i
import src/util/randomutil
import src/util/gamestate

import random
import test
import array
import control

// TODO: Decide for s = status or c = cell as parameters

type Cell {
  Moon();
  Sun();
  Empty();
}

def isEmptyCell(c: Cell): Bool / {} = {
  c match {
    case Empty() => true
    case _ => false
  }
}

def equals(a: Cell, b: Cell): Bool / {} = {
  (a, b) match {
    case (Moon(), Moon()) => true
    case (Sun(), Sun()) => true
    case (Empty(), Empty()) => true
    case _ => false
  }
}

def infixEq(a: Cell, b: Cell): Bool / {} = {
  a.equals(b)
}

def show(c: Cell): String / {} = {
  c match {
    case Moon() => "M"
    case Sun() => "S"
    case Empty() => "."
  }
}

type Board = Gamegrid[Cell] // TODO: Maybe use Cell record? If not, change in zip

type ConstraintType {
  Equal();
  Diff();
}

record Constraint(from: Vec2i, to: Vec2i, typ: ConstraintType)

def satisfies(board: Board, constr: Constraint): Bool / {} = {
  constr.typ match {
    case Equal() => equals(board.get(constr.from), board.get(constr.to))
    case Diff() => not(equals(board.get(constr.from), board.get(constr.to)))
  }
}

interface Search {
  def pickSymbol(v: (Int, Int)): Cell
  def fail(): Nothing
}

def placeAllSymbolCombinations(board: Board): List[Board] / {} = {
  try {
    var new_board = board.copy()

    [0,1,2,3,4,5].foreach {col =>
      [0,1,2,3,4,5].foreach {row =>
        val symbol = do pickSymbol((col, row))

        if(new_board.isValidPlacement((col, row), symbol)) {
          new_board = new_board.setCopy((col, row), symbol)
        }
        else {
          do fail()
        }
      }
    }

    [new_board]

  } with Search {
    def pickSymbol(v) = {
      resume(Moon()).append(resume(Sun()))
    }

    def fail() = {[]}
  }
}

def placeOneSymbolCombination(board: Board): Board / {random, Exception[MissingValue]} = {
  try {
    var new_board = board.copy()

    [0,1,2,3,4,5].foreach {col =>
      [0,1,2,3,4,5].foreach {row =>
        val symbol = do pickSymbol((col, row))

        if(new_board.isValidPlacement((col, row), symbol)) {
          new_board = new_board.setCopy((col, row), symbol)
        }
        else {
          do fail()
        }
      }
    }

    Some(new_board)

  } with Search {
    def pickSymbol(v) = {
      var o_board: Option[Board] = None()

      [Moon(), Sun()].shuffle().foreach{(s) {l: Label} =>
        resume(s) match {
          case Some(b) => {
            o_board = Some(b)
            l.break()
          }
          case None() => l.continue()
        }
      }

      o_board
    }

    def fail() = {None()}
  }
  .value
}

def generateGame(): Board / {random} = {
  var board = gamegrid::init(6, 6, Empty())

  with on[MissingValue].panic()
  board = board.placeOneSymbolCombination()

  board
}

// TODO: Test
def threeInARow(board: Board, row: Int): Bool / {} = {
  var last_symbol = Empty()
  var n_repeating = 0

  var tree_in_a_row = false

  board.horizontalCellsOf(row).foreach {(s) {l: Label} =>
    if(n_repeating == 3) {
      tree_in_a_row = true
      l.break()
    }

    s match {

      case Moon() => {
        if (last_symbol == Moon()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Moon()
        }
      }

      case Sun() => {
        if (last_symbol == Sun()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Sun()
        }
      }

      case Empty() => {
        n_repeating = 0
        last_symbol = Empty()
      }
    }
  }

  tree_in_a_row
}

// TODO: Test
def threeInACol(board: Board, col: Int): Bool / {} = {
  var last_symbol = Empty()
  var n_repeating = 0

  var tree_in_a_col = false

  board.verticalCellsOf(col).foreach {(s) {l: Label} =>
    if(n_repeating == 3) {
      tree_in_a_col = true
      l.break()
    }

    s match {

      case Moon() => {
        if (last_symbol == Moon()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Moon()
        }
      }

      case Sun() => {
        if (last_symbol == Sun()) {
          n_repeating = n_repeating + 1
        }
        else {
          n_repeating = 1
          last_symbol = Sun()
        }
      }

      case Empty() => {
        n_repeating = 0
        last_symbol = Empty()
      }
    }
  }

  tree_in_a_col
}

// TODO: Check constraints
// TODO: Refactor
// TODO: Improve
def isValidPlacement(board: Board, v: Vec2i, c: Cell): Bool / {} = {
  // Checking all vertical cells how many symbols there are
  var vert_num_suns = board.verticalCellsExcluding(v).count {c => c.equals(Sun())}
  var vert_num_moons = board.verticalCellsExcluding(v).count {c => c.equals(Moon())}

  // Checking all horizontal cells how many symbols there are
  var horiz_num_suns = board.horizontalCellsExcluding(v).count {c => c.equals(Sun())}
  var horiz_num_moons = board.horizontalCellsExcluding(v).count {c => c.equals(Moon())}

  // Adding the symbol that would be placed
  c match {
    case Moon() => {vert_num_moons = vert_num_moons + 1
                    horiz_num_moons = horiz_num_moons + 1}
    case Sun() => {vert_num_suns = vert_num_suns + 1
                    horiz_num_suns = horiz_num_suns + 1}
    case _ => ()
  }

  val new_board = board.setCopy(v, c)

  vert_num_moons <= 3 && horiz_num_moons <= 3 &&
  vert_num_suns <= 3 && horiz_num_suns <= 3 &&
  not(new_board.threeInACol(v.x)) && not(new_board.threeInARow(v.y))
}

// TODO: Improve performance
def isWinning(board: Board, constraints: List[Constraint]): Bool / {} = {
  var isValid = true

  // Checking about number of moons and suns
  [0,1,2,3,4,5].foreach {(c) {l: Label} =>
    val num_suns = board.verticalCellsOf(c).count {c => c.equals(Sun())}
    val num_moons = board.verticalCellsOf(c).count {c => c.equals(Moon())}
    val num_empty = board.verticalCellsOf(c).count {c => c.equals(Empty())}

    if(num_suns != 3 || num_moons != 3 || num_empty > 0) {
      isValid = false
      l.break()
    }
  }

  // Checking for 3 in a col
  [0,1,2,3,4,5].foreach {(c) {l: Label} =>
    if(board.threeInACol(c)) {
      isValid = false
      l.break()
    }
  }

  // Checking for 3 in a row
  [0,1,2,3,4,5].foreach {(r) {l: Label} =>
    if(board.threeInARow(r)) {
      isValid = false
      l.break()
    }
  }

  // Checking if all constraints match
  constraints.foreach {(constr) {l: Label} =>
    if(not(board.satisfies(constr))) {
      isValid = false
      l.break()
    }
  }

  isValid
}

def showBoard(board: Board): Gamegrid[String] / {} = {
  board.map {show}
}

def gameloop(board: Board): Unit / {Gamestate} = {
  do updateGrid(showBoard(board))
}

def playGame(): Unit / {random, Gamestate} = {
  with on[RuntimeError].panic();

  var board = gamegrid::init(6, 6, Empty())
  board = generateGame()

  gameloop(board)
}

def testSuite(): Bool = suite("games/tango") {

  test("isWinningNoConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    assertTrue(b.isWinning([]))
  }

  test("isNotWinningNoConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Moon(), Moon(), Sun(), Moon(), Sun(), // One moon too many
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    assertFalse(b.isWinning([]))
  }

  test("isWinningWithConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    val constraints = [Constraint((0,0), (1,0), Diff()),
                       Constraint((0, 1), (0, 2), Equal()),
                       Constraint((5, 0), (5, 1), Equal())]

    assertTrue(b.isWinning(constraints))
  }

  test("isNotWinningWithConstraints") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    val constraints = [Constraint((0,1), (0,2), Diff()), // Is not satisfied
                       Constraint((5, 0), (5, 1), Equal())]

    assertFalse(b.isWinning(constraints))
  }

  test("isNotWinning3AfterAnother") {
    val b = Gamegrid(6, 6, fromList([Moon(), Moon(), Moon(), Sun(), Sun(), Sun(), // Is not valid since 3 in a row
                                     Moon(), Moon(), Moon(), Sun(), Sun(), Sun(),
                                     Moon(), Moon(), Moon(), Sun(), Sun(), Sun(),
                                     Sun(), Sun(), Sun(), Moon(), Moon(), Moon(),
                                     Sun(), Sun(), Sun(), Moon(), Moon(), Moon(),
                                     Sun(), Sun(), Sun(), Moon(), Moon(), Moon()]))

    assertFalse(b.isWinning([]))
  }

  test("isValidPlacement") {
    val b = gamegrid::init(6, 6, Empty())

    assertTrue(b.isValidPlacement((1, 1), Moon()))
  }

  test("isNotValidPlacement") {
    val b = Gamegrid(6, 6, fromList([Moon(), Sun(), Sun(), Moon(), Sun(), Moon(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(), // placing Moon to (0, 1)
                                     Sun(), Moon(), Moon(), Sun(), Moon(), Sun(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun(),
                                     Sun(), Moon(), Sun(), Sun(), Moon(), Moon(),
                                     Moon(), Sun(), Moon(), Moon(), Sun(), Sun()]))

    assertFalse(b.isValidPlacement((0, 1), Moon()))
  }

  test("isNotValidPlacement3AfterAnother") {
    val b = Gamegrid(6, 6, fromList([Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Moon(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(), // Is not valid since 3 in a row
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty(),
                                     Empty(), Empty(), Empty(), Empty(), Empty(), Empty()]))

    assertFalse(b.isValidPlacement((0, 3), Moon()))
  }


  test("allGamesValid") {
    val b = gamegrid::init(6, 6, Empty())
    val all_boards = placeAllSymbolCombinations(b)

    assertTrue(all_boards.all {b => b.isWinning([])})
  }
}