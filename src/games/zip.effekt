import src/util/gamegrid
import src/util/randomUtil
import src/util/vec2i
import src/util/gamestate

import random
import bench
import test
import stream
import tty

type Status {
  Pathelement(i: Int)
  Empty();
}

record Cell(status: Status)

val EMPTY_CELL = Cell(Empty())

def show(c: Cell): String / {} = {
  show(c.status)
}

def show(s: Status): String / {} = {
  s match {
    case Pathelement(i) => show(i)
    case Empty() => "~"
  }
}

def isEmptyCell(c: Cell): Bool / {} = {
  c.status match {
    case Empty() => true
    case _ => false
  }
}

interface Search {
  def pickNextCell(available_cells: List[Vec2i]): Vec2i
  def fail(): Nothing
}

type Maze = Gamegrid[Cell]

def findPaths(maze: Maze, start: Vec2i): List[Maze] / {} = {
  try {
    var new_maze = maze.copy()
    var curr_pos = start
    var curr_path_length = 0

    exhaustively { // TODO: Transform this to a fixed number of iterations (somehow)
      curr_path_length = curr_path_length + 1
      new_maze = new_maze.setCopy(curr_pos, Cell(Pathelement(curr_path_length)))

      val valid_next_cells = new_maze.surroundingCells4WithIndices(curr_pos)
                                     .filter {t => t.second.isEmptyCell() } // allow only empty cells
                                     .map {t => t.first} // get coordinates

      if (valid_next_cells.isEmpty && curr_path_length < maze.width * maze.height) {
        do fail()
      }

      if (valid_next_cells.isEmpty && curr_path_length == maze.width * maze.height) {
        do stop()
      }

      var next_pos = do pickNextCell(valid_next_cells) // TODO: Rename

      curr_pos = next_pos
    }

    [new_maze]
  } with Search {
      def pickNextCell(available_cells) = {
        var mazes: List[Maze] = []

        available_cells.foreach {v =>
          mazes = resume(v).append(mazes)
        }
        mazes
      }
      def fail() = {[]}
  }
}

def extractPath(maze: Maze): List[Vec2i] / {} = {
  with on[RuntimeError].panic();
  maze.mapWithIndex {(v, c) => (v, c)}
      .grid.toList()
      .sortBy {(t1, t2) => {
          (t1.second.status, t2.second.status) match { // compare with Number in Cell
            case (Pathelement(i), Pathelement(j)) => i <= j
            case _ => raise("Cant build Path with Empty Cells!")
          }}
      }
      .map {t => t.first} // extract only Vector again
}

def hidePath(maze: Maze): Maze /  {random} = {
  val path_length = maze.width * maze.height
  val keep_factor = 0.4 // TODO: Make variable

  val path = maze.extractPath()
  var new_path: List[Vec2i] = []

  path.take(path_length - 1).drop(1) // We dont want to remove the start or end
      .foreach {v =>
        bernoulli(keep_factor)
        {
          new_path = Cons(v, new_path)
        }
        {
          () // In case of 1 - keep_factor, we dont take this node into the path (hide it)
        }
      }

  with on[MissingValue].panic();
  new_path = Cons(path.last(), new_path) // Add end again
  new_path = new_path.reverse()
  new_path = Cons(path.head(), new_path) // Add start again


  var new_maze = init(maze.width, maze.height, EMPTY_CELL)

  var index = 1
  new_path.foreach {v =>
    new_maze.set(v, Cell(Pathelement(index)))
    index = index + 1
  }


  new_maze
}

def generateGame(size: Int): Maze / {random} = {
  var maze = gamegrid::init(size, size, EMPTY_CELL)

  exhaustively { // TODO: Make this different
    val start = pickRandomElement(list::build(maze.width * maze.height) {i => indexToCoords(i, maze.width)})

    val mazes = findPaths(maze, start)

    if(mazes.size > 0) {
      maze = pickRandomElement(mazes)
      do stop()
    }
  }

  maze
}

def isWinning(maze: Maze, path: List[Vec2i]): Bool / {} = {
  with on[MissingValue].panic;
  if(path.size < maze.width * maze.height || maze.get(path.last).isEmptyCell()) {
    false
  }
  else {
    var last_index = 0
    var is_sorted = true

    path.foreach {v =>
      val c = maze.get(v)
      c.status match {
        case Pathelement(i) => if (i < last_index) {is_sorted = false} // TODO: Break here somehow
        case Empty() => () // we dont care when empty cells are visited
      }
    }

    is_sorted
  }
}

// Remove turnbacks
def cleanupPath(path: List[Vec2i]): List[Vec2i] / {} = {
  if(path.size <= 2) {
    path
  }
  else {
    path match {
      case Cons(a, Cons(b, Cons(c, rst))) => if (a == c) // This means it turned back after b
                                              {Cons(a, cleanupPath(rst))} // removing unnecessary b and c
                                             else
                                              {Cons(a, cleanupPath(Cons(b, Cons(c, rst))))}
      case _ => path
    }
  }
}

def validNextMoves(maze: Maze, cursor: Vec2i, path: List[Vec2i]): List[InputOption] = {
  val input_options = [
    (InputOption("w", "Cursor up"), (0, -1)),
    (InputOption("s", "Cursor down"), (0, 1)),
    (InputOption("a", "Cursor left"), (-1, 0)),
    (InputOption("d", "Cursor right"), (1, 0))
  ]

  input_options.filter {t =>
    val new_cursor = cursor + t.second

    with on[OutOfBounds].panic();
    val is_stepback = path.size >= 2 && (new_cursor == path.get(path.size - 2))

    maze.isInBound(new_cursor) &&
    (not(path.contains(new_cursor) {vec2i::equals}) || is_stepback)
  }.map() {t => t.first} // returning only InputOption
}

def gameloop(maze: Maze): Unit / {Gamestate} = {
  with on[RuntimeError].panic();
  with on[MissingValue].panic();
  // TODO: Rewrite this - its just finding the start ...
  var cursor = maze.mapWithIndex {(v, c) => (v, c)}
                   .grid.toList()
                   .sortBy {(t1, t2) => {
                      (t1.second.status, t2.second.status) match { // compare with Number in Cell
                        case (Pathelement(i), Pathelement(j)) => i <= j
                        case (Pathelement(i), Empty()) => true
                        case (Empty(), Pathelement(j)) => false
                        case (Empty(), Empty()) => true
                      }}
                    }
                   .head().first
  var current_maze = maze
  var current_path: List[Vec2i] = [cursor]

  exhaustively() {
    if(current_maze.isWinning(current_path)) {
      do stop()
    }

    // Sending current board to console
    val max_index_len = maze.grid.foldLeft(0) {(acc, c) => max(acc, show(c).length)}
    do updateGrid(maze.mapWithIndex {(v, c) => {
        var s = show(c).padLeft(max_index_len)

        if(v == cursor) {s = Escape::BLINK ++ s ++ Escape::RESET} // adding blinking cursor
        if(current_path.contains(v) {vec2i::equals}) {s = "\u001b[31m" ++ s ++ Escape::RESET}

        s
    }})

    // applying input of user
    var old_cursor = cursor // < In case the new coords are out of bound

    val input = do getUserInput(validNextMoves(maze, cursor, current_path))

    input match {
      case "w" => {cursor = cursor + (0,-1)}
      case "a" => {cursor = cursor + (-1,0)}
      case "s" => {cursor = cursor + (0,1)}
      case "d" => {cursor = cursor + (1,0)}
      case _ => println("Invalid Input!") // TODO: Fix this, maybe continue?
    }

    current_path = current_path.append([cursor])
    current_path = cleanupPath(current_path)

  }

  do gameWon("You won ZIP!") // TODO: Something pretty
}

def testSuite(): Bool = suite("games/zip") {

  test("findPaths2x2") {
    assertEqual(gamegrid::init(2, 2, EMPTY_CELL).findPaths((0,0)).size,
                2) // verified
  }

  test("findPaths3x3") {
    assertEqual(gamegrid::init(3, 3, EMPTY_CELL).findPaths((0,0)).size,
                8) // verified
  }

  test("findPaths4x4") {
    assertFalse(gamegrid::init(4, 4, EMPTY_CELL).findPaths((0,0)).isEmpty)
  }

  test("findPaths5x5") {
    assertFalse(gamegrid::init(5, 5, EMPTY_CELL).findPaths((0,0)).isEmpty)
  }

  test("findPaths6x6") {
    assertFalse(gamegrid::init(6, 6, EMPTY_CELL).findPaths((0,0)).isEmpty)
  }

  test("findPaths3x3Middle") {
    assertEqual(gamegrid::init(3, 3, EMPTY_CELL).findPaths((1,1)).size,
                8) // verified
  }
}
