import src/util/gamegrid
import src/util/randomUtil
import src/util/vec2i

import random
import bench
import test
import stream
import tty

type Status {
  Pathelement(i: Int)
  Empty();
}

record Cell(status: Status)

val EMPTY_CELL = Cell(Empty())

def show(c: Cell): String / {} = {
  show(c.status)
}

def show(s: Status): String / {} = {
  s match {
    case Pathelement(i) => show(i)
    case Empty() => " "
  }
}

def isEmptyCell(c: Cell): Bool / {} = {
  c.status match {
    case Empty() => true
    case _ => false
  }
}

interface Search {
  def pickNextCell(available_cells: List[Vec2i]): Vec2i
  def fail(): Nothing
}

type Maze = Gamegrid[Cell]

def findPaths(maze: Maze, start: Vec2i): List[Maze] / {} = {
  try {
    var new_maze = maze.copy()
    var curr_pos = start
    var curr_path_length = 0

    exhaustively { // TODO: Transform this to a fixed number of iterations (somehow)
      curr_path_length = curr_path_length + 1
      new_maze = new_maze.setCopy(curr_pos, Cell(Pathelement(curr_path_length)))

      val valid_next_cells = new_maze.surroundingCells4WithIndices(curr_pos)
                                     .filter {t => t.second.isEmptyCell() } // allow only empty cells
                                     .map {t => t.first} // get coordinates

      if (valid_next_cells.isEmpty && curr_path_length < maze.width * maze.height) {
        do fail()
      }

      if (valid_next_cells.isEmpty && curr_path_length == maze.width * maze.height) {
        do stop()
      }

      var next_pos = do pickNextCell(valid_next_cells) // TODO: Rename

      curr_pos = next_pos
    }

    [new_maze]
  } with Search {
      def pickNextCell(available_cells) = {
        var mazes: List[Maze] = []

        available_cells.foreach {v =>
          mazes = resume(v).append(mazes)
        }
        mazes
      }
      def fail() = {[]}
  }
}

def extractPath(maze: Maze): List[Vec2i] / {} = {
  with on[RuntimeError].panic();
  maze.mapWithIndex {(v, c) => (v, c)}
      .grid.toList()
      .sortBy {(t1, t2) => {
          (t1.second.status, t2.second.status) match { // compare with Number in Cell
            case (Pathelement(i), Pathelement(j)) => i <= j
            case _ => raise("Cant build Path with Empty Cells!")
          }}
      }
      .map {t => t.first} // extract only Vector again
}

def hidePath(maze: Maze): Maze /  {random} = {
  val path_length = maze.width * maze.height
  val keep_factor = 0.4 // TODO: Make variable

  val path = maze.extractPath()
  var new_path: List[Vec2i] = []

  path.take(path_length - 1).drop(1) // We dont want to remove the start or end
      .foreach {v =>
        bernoulli(keep_factor)
        {
          new_path = Cons(v, new_path)
        }
        {
          () // In case of 1 - keep_factor, we dont take this node into the path (hide it)
        }
      }

  with on[MissingValue].panic();
  new_path = Cons(path.last(), new_path) // Add end again
  new_path = new_path.reverse()
  new_path = Cons(path.head(), new_path) // Add start again


  var new_maze = init(maze.width, maze.height, EMPTY_CELL)

  var index = 1
  new_path.foreach {v =>
    new_maze.set(v, Cell(Pathelement(index)))
    index = index + 1
  }


  new_maze
}


def show_maze(maze: Maze): String / {} = {

  val max_index_len = maze.grid.foldLeft(0) {(acc, c) => max(acc, show(c).length)}

  show(
    maze.map {c => show(c).padLeft(max_index_len)}
  )
}


def generateGame(size: Int): Maze / {} = {
  var maze = gamegrid::init(size, size, EMPTY_CELL)

  minstd(timestamp()) {

    exhaustively { // TODO: Make this different
      val start = pickRandomElement(list::build(maze.width * maze.height) {i => indexToCoords(i, maze.width)})

      val mazes = findPaths(maze, start)

      if(mazes.size > 0) {
        maze = pickRandomElement(mazes)
        do stop()
      }
    }
  }

  maze
}

def main() = {
  var m = generateGame(3)

  println(show_maze(m))

  minstd(timestamp()) {
    m = m.hidePath()
  }

  println("-----")
  println(show_maze(m))
}

def testSuite(): Bool = suite("games/zip") {

  test("findPaths2x2") {
    assertEqual(gamegrid::init(2, 2, EMPTY_CELL).findPaths((0,0)).size,
                2) // verified
  }

  test("findPaths3x3") {
    assertEqual(gamegrid::init(3, 3, EMPTY_CELL).findPaths((0,0)).size,
                8) // verified
  }

  test("findPaths4x4") {
    assertFalse(gamegrid::init(4, 4, EMPTY_CELL).findPaths((0,0)).isEmpty)
  }

  test("findPaths5x5") {
    assertFalse(gamegrid::init(5, 5, EMPTY_CELL).findPaths((0,0)).isEmpty)
  }

  test("findPaths6x6") {
    assertFalse(gamegrid::init(6, 6, EMPTY_CELL).findPaths((0,0)).isEmpty)
  }

  test("findPaths3x3Middle") {
    assertEqual(gamegrid::init(3, 3, EMPTY_CELL).findPaths((1,1)).size,
                8) // verified
  }
}
