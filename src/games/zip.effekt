module src/games/zip

import src/util/gamegrid
import src/util/randomutil
import src/util/vec2i
import src/util/gamestate
import src/util/connection

import random
import test
import stream
import tty
import set
import control
import io/console
import io/time

type Status {
  Pathelement(i: Int)
  Empty();
}

record Cell(status: Status)

def equals(c1: Cell, c2: Cell): Bool / {} = {
  (c1.status, c2.status) match {
    case (Pathelement(i), Pathelement(j)) => i == j
    case (Empty(), Empty()) => true
    case _ => false
  }
}

val EMPTY_CELL = Cell(Empty())

def show(c: Cell): String / {} = {
  show(c.status)
}

def show(s: Status): String / {} = {
  s match {
    case Pathelement(i) => show(i)
    case Empty() => "."
  }
}

def isEmptyCell(c: Cell): Bool / {} = {
  c.status match {
    case Empty() => true
    case _ => false
  }
}

val INPUT_OPTIONS = [
    (InputOption("w", "Cursor up"), (0, -1)),
    (InputOption("s", "Cursor down"), (0, 1)),
    (InputOption("a", "Cursor left"), (-1, 0)),
    (InputOption("d", "Cursor right"), (1, 0))
]

interface Search {
  def pickNextCell(available_cells: List[Vec2i]): Vec2i
  def fail(): Nothing
}

type Maze = Gamegrid[Cell]

type Border = Connection[Unit] // determines, if there is a border between two cells
def Border(u: Vec2i, v: Vec2i) = Connection(u, v, ()) // TODO: Check if necessary


def generatePaths(maze: Maze, start: Vec2i): List[Maze] / {} = {
  try {
    var new_maze = maze.copy()
    var curr_pos = start
    var curr_path_length = 0

    loop { // TODO: Transform this to a fixed number of iterations (somehow)
      curr_path_length = curr_path_length + 1
      new_maze = new_maze.setCopy(curr_pos, Cell(Pathelement(curr_path_length)))

      val valid_next_cells = new_maze.surroundingCells4WithIndices(curr_pos)
                                     .filter {t => t.second.isEmptyCell() } // allow only empty cells
                                     .map {t => t.first} // get coordinates

      if (valid_next_cells.isEmpty && curr_path_length < maze.width * maze.height) {
        do fail()
      }

      if (valid_next_cells.isEmpty && curr_path_length == maze.width * maze.height) {
        do stop()
      }

      var next_cell = do pickNextCell(valid_next_cells)

      curr_pos = next_cell
    }

    [new_maze]
  } with Search {
      def pickNextCell(available_cells) = {
        var mazes: List[Maze] = []

        available_cells.foreach {v =>
          mazes = resume(v).append(mazes)
        }
        mazes
      }
      def fail() = {[]}
  }
}

def generateSinglePath(maze: Maze, start: Vec2i): Option[Maze] / {random} = { // TODO: Unpack Option already here, like Tango
  try {
    var new_maze = maze.copy()
    var curr_pos = start
    var curr_path_length = 0

    loop { // TODO: Transform this to a fixed number of iterations (somehow)
      curr_path_length = curr_path_length + 1
      new_maze = new_maze.setCopy(curr_pos, Cell(Pathelement(curr_path_length)))

      val valid_next_cells = new_maze.surroundingCells4WithIndices(curr_pos)
                                     .filter {t => t.second.isEmptyCell() } // allow only empty cells
                                     .map {t => t.first} // get coordinates

      if (valid_next_cells.isEmpty && curr_path_length < maze.width * maze.height) {
        do fail()
      }

      if (valid_next_cells.isEmpty && curr_path_length == maze.width * maze.height) {
        do stop()
      }

      var next_cell = do pickNextCell(valid_next_cells)

      curr_pos = next_cell
    }

    Some(new_maze)
  } with Search {
      def pickNextCell(available_cells: List[Vec2i]) = {
        var o_maze: Option[Maze] = None()

        shuffle(available_cells).foreach {(v) {l: Label} =>
          resume(v) match {
            case Some(m) => {
              o_maze = Some(m)
              l.break()
            }
            case None() => l.continue()
          }
        }
        o_maze
      }

      def fail() = {None()}
  }
}

def extractPath(maze: Maze): List[Vec2i] / {} = {
  with on[RuntimeError].panic();
  maze.mapWithIndex {(v, c) => (v, c)}
      .grid.toList()
      .sortBy {(t1, t2) => {
          (t1.second.status, t2.second.status) match { // compare with Number in Cell
            case (Pathelement(i), Pathelement(j)) => i <= j
            case _ => raise("Cant build Path with Empty Cells!")
          }}
      }
      .map {t => t.first} // extract only Vector again
}

def hidePath(maze: Maze, keep_factor: Double): Maze /  {random} = {
  val path_length = maze.width * maze.height

  val path = maze.extractPath()
  var new_path: List[Vec2i] = []

  path.take(path_length - 1).drop(1) // We dont want to remove the start or end
      .foreach {v =>
        bernoulli(keep_factor)
        {
          new_path = Cons(v, new_path)
        }
        {
          () // In case of 1 - keep_factor, we dont take this node into the path (hide it)
        }
      }

  with on[MissingValue].panic();
  new_path = Cons(path.last(), new_path) // Add end again
  new_path = new_path.reverse()
  new_path = Cons(path.head(), new_path) // Add start again


  var new_maze = init(maze.width, maze.height, EMPTY_CELL)

  var index = 1
  new_path.foreach {v =>
    new_maze.set(v, Cell(Pathelement(index)))
    index = index + 1
  }

  new_maze
}

def hideBorders(borders: List[Border], keep_factor: Double): List[Border] / {random} = {
  var new_borders: List[Border] = []

  borders.foreach {v =>
    bernoulli(keep_factor)
    {
      new_borders = Cons(v, new_borders)
    }
    {
      () // In case of 1 - keep_factor, we dont take this border into the new_borders
    }
  }

  new_borders
}

def generateAllBordersFromPath(maze: Maze, p: List[Vec2i]): List[Border] / {} = {

  // turns a list of nodes to a list of start and end nodes (virtually a border)
  def transformPath(path: List[Vec2i]): List[Border] / {} = {
    path match {
      case Cons(v1, Cons(v2, rst)) => Cons(Border(v1, v2),
                                           transformPath(Cons(v2, rst)))
      case Cons(v1, Nil()) => []
      case Nil() => []
    }
  }

  val p_trans = p.transformPath()

  var borders: List[Border] = []

  maze.mapWithIndex {(v, a) => v} // TODO: Make foreachIndex availabe
      .grid.foreach {v =>
            val neighs = maze.surroundingCells4WithIndices(v).map {x => x.first}
            neighs.foreach {u =>
              val b = Border(v, u)
              // if path contains both cells, we dont place a border
              if(not(p_trans.contains(b) { (a, b) => connection::equals(a, b) })) {

                // if borders does not yet contain this edge
                if(not(borders.contains(b) { (a, b) => connection::equals(a, b) })) {
                  borders = Cons(b, borders)
                }
              }
            }
        }

  borders
}

def generateGame(size: Int): Maze / {random} = {
  var maze = gamegrid::init(size, size, EMPTY_CELL)

  loop { // TODO: Make this different
    val start = pickRandomElement(list::build(maze.width * maze.height) {i => indexToCoords(i, maze.width)})

    generateSinglePath(maze, start) match {
      case Some(m) => {
        maze = m
        do stop()
      }
      case None() => ()
    }
  }

  // TODO: Why?
  val path = maze.extractPath()
  val borders = maze.generateAllBordersFromPath(path)

  maze
}

def isWinning(maze: Maze, path: List[Vec2i], borders: List[Border]): Bool / {} = {
  with on[MissingValue].panic;
  if(path.size < maze.width * maze.height || maze.get(path.last).isEmptyCell()) {
    false
  }
  else {
    var last_index = 0
    var is_sorted = true

    var contains_duplicates = false
    var visited: Set[Vec2i] = empty(box vec2i::compare)

    var last_cell = (-1, -1) // does not exist, so is a safe default value
    var crosses_border = false

    path.foreach {(v) {l: Label} =>

      // Checking vor duplicates
      if(visited.contains(v)) {
        contains_duplicates = true
        l.break()
      }
      visited.insert(v)

      // Checking if visited cells are in ascending order
      val c = maze.get(v)
      c.status match {
        case Pathelement(i) => {
          if (i < last_index) {
              is_sorted = false
              l.break()
          }
          last_index = i
        }
        case Empty() => () // we dont care when empty cells are visited
      }

      // Checking for border crossing
      val b = Border(v, last_cell)
      if (borders.contains(b) {(a, b) => connection::equals(a, b)}) {
        crosses_border = true
      }

      last_cell = v
    }

    is_sorted && not(contains_duplicates) && not(crosses_border)
  }
}

// Remove turnbacks
def cleanupPath(path: List[Vec2i]): List[Vec2i] / {} = {
  if(path.size <= 2) {
    path
  }
  else {
    path match {
      case Cons(a, Cons(b, Cons(c, rst))) => if (a == c) // This means it turned back after b
                                              {Cons(a, cleanupPath(rst))} // removing unnecessary b and c
                                             else
                                              {Cons(a, cleanupPath(Cons(b, Cons(c, rst))))}
      case _ => path
    }
  }
}

def validNextMoves(maze: Maze, cursor: Vec2i, path: List[Vec2i], borders: List[Border]): List[InputOption] = {
  INPUT_OPTIONS.filter {t =>
    val new_cursor = cursor + t.second

    with on[OutOfBounds].panic();
    val is_stepback = path.size >= 2 && (new_cursor == path.get(path.size - 2))

    maze.isInBound(new_cursor) && // cell is in bound of Grid
    not(borders.contains(Border(cursor, new_cursor)) { (a, b) => connection::equals(a, b) }) && // no Border between next cell
    (not(path.contains(new_cursor) {vec2i::equals}) || is_stepback) // only new cells (not visited yet) or the previous cell (stepback)
  }.map() {t => t.first} // returning only InputOption
}

def findStart(maze: Maze): Vec2i / {} = {
  with on[RuntimeError].panic();
  maze.grid.indexOf(Cell(Pathelement(1))) {(a, b) => a.equals(b)} match { // Searching for Pathelement of index 1
            case Some(i) => indexToCoords(i, maze.width)
            case None() => raise("Can not find start in grid!")
  }
}

def show_maze(maze: Maze, path: List[Vec2i], cursor: Vec2i, borders: List[Border]): Gamegrid[String] / {} = {

  val max_index_len = maze.grid.foldLeft(0) {(acc, c) => max(acc, show(c).length)}
  val PATH_SYMBOL = "\u001b[31m" ++ "$".padLeft(max_index_len) ++ Escape::RESET // TODO: Find out how to to this reasonable
  val BORDER_VERT_SYMBOL = "\u001b[34m" ++ "|".padLeft(max_index_len) ++ Escape::RESET // TODO: Find out how to to this reasonable
  val BORDER_HORIZ_SYMBOL = "\u001b[34m" ++ "-".padLeft(max_index_len) ++ Escape::RESET // TODO: Find out how to to this reasonable

  // Returns either the vertical or horizontal border, depending on cell relation
  def orientedBorderSymbol(v: Vec2i, u: Vec2i): String / {} = {
    if(v.x - u.x != 0) { // cells are next to each other
      BORDER_VERT_SYMBOL
    }
    else if (v.y - u.y != 0) { // cells are above each other
      BORDER_HORIZ_SYMBOL
    }
    else { // cells are diagonal - should not happen! TODO: Fix
      "?"
    }
  }

  // turns a list of nodes to a list of start and end nodes, with the symbol it will have in the extended grid
  def transformPath(path: List[Vec2i]): List[(Vec2i, Vec2i)] / {} = {
    path match {
      case Cons(v1, Cons(v2, rst)) => Cons((v1, v2),
                                           transformPath(Cons(v2, rst)))
      case Cons(v1, Nil()) => []
      case Nil() => []
    }
  }

  // Transform 2-tuple to 3-tuple
  def extendTuple[A, B, C](t: (A, B), c: C): (A, B, C) = {
    (t.first, t.second, c)
  }

  var connections: List[(Vec2i, Vec2i, String)] = []
  connections = connections.append(transformPath(path).map {x => x.extendTuple(PATH_SYMBOL)})
  connections = connections.append(borders.map {x => extendTuple((x.from, x.to), orientedBorderSymbol(x.from, x.to))}) // TODO: Find a general way to extend

  maze.mapWithIndex {(v, c) => {
        var s = show(c).padLeft(max_index_len)

        if(v == cursor) {s = Escape::BLINK ++ s ++ Escape::RESET} // adding blinking cursor
        if(path.contains(v) {vec2i::equals}) {s = "\u001b[31m" ++ s ++ Escape::RESET}

        s}}
      .extendGridBy1Connecting(" ".padLeft(max_index_len), connections) // grid is extended, free space is filled with ' ' and cells that are in path are filled with PATH_SYMBOL
}

def gameloop(maze: Maze, borders: List[Border]): Unit / {Gamestate[Cell, Unit]} = {
  var cursor = findStart(maze)

  var current_maze = maze
  var current_path: List[Vec2i] = [cursor]

  loop {{l: Label} =>
    // Sending current board to console
    do updateGrid(current_maze, show_maze(current_maze, current_path, cursor, borders), borders)

    if(current_maze.isWinning(current_path, borders)) {
      l.break()
    }

    // applying input of user
    var old_cursor = cursor // < In case the new coords are out of bound

    val valid_moves = validNextMoves(maze, cursor, current_path, borders)
    val input = do getUserInput(valid_moves
                                .append([InputOption("r", "Reset")]))

    input match {
      case "w" => {cursor = cursor.addOntoIfInBound((0, -1), maze)}
      case "a" => {cursor = cursor.addOntoIfInBound((-1, 0), maze)}
      case "s" => {cursor = cursor.addOntoIfInBound((0, 1), maze)}
      case "d" => {cursor = cursor.addOntoIfInBound((1, 0), maze)}
      case "r" => {cursor = findStart(current_maze)
                   current_path = []}
      case _ => l.continue()
    }

    current_path = current_path.append([cursor])
    current_path = cleanupPath(current_path)
  }

  do gameWon(
  """
 __     __                                 _______       _
 \ \   / /                                |___  (_)     | |
  \ \_/ /__  _   _  __      _____  _ __      / / _ _ __ | |
   \   / _ \| | | | \ \ /\ / / _ \| '_ \    / / | | '_ \| |
    | | (_) | |_| |  \ V  V / (_) | | | |  / /__| | |_) |_|
    |_|\___/ \__,_|   \_/\_/ \___/|_| |_| /_____|_| .__/(_)
                                                  | |
                                                  |_|

  """
  )
}

def playGame(size: Int, path_keep_factor: Double, border_keep_factor: Double): Unit / {random, Gamestate[Cell, Unit]} = {
  var maze = generateGame(size)
  var path = maze.extractPath()
  var borders = maze.generateAllBordersFromPath(path)

  maze = maze.hidePath(path_keep_factor)
  borders = borders.hideBorders(border_keep_factor)

  gameloop(maze, borders)
}

def findWorkingPath(maze: Maze, borders: List[Border]): Option[List[Vec2i]] / {} = {
    val all_mazes = generatePaths(init(maze.width, maze.height, EMPTY_CELL), maze.findStart) // TODO: Filter
    var path: Option[List[Vec2i]] = None()

    all_mazes.foreach {(m) {l: Label} =>
      val p = extractPath(m)

      if(maze.isWinning(p, borders)) {
        path = Some(p)
        l.break()
      }
    }

    path
}

def solve(wait_time: Int) {gameloop: () => Unit / {Gamestate[Cell, Unit]}} = {
  var last_viz_grid: Gamegrid[String] = init(1, 1, "") // Dummy value // TODO: Give function to vizualize the grid..
  var last_grid: Gamegrid[Cell] = init(1, 1, EMPTY_CELL)

  var path: List[Vec2i] = []
  var cursor = (0, 0)

  with console;
  try {
    gameloop()
  } with Gamestate[Cell, Unit] {

      def getUserInput(allowed) = {

        // Determening next Move
        with on[MissingValue].panic();
        path = path.drop(1) // lose first element of path, since we are already there
        val next_cell = path.head()

        val working_input_option = INPUT_OPTIONS.filter {t =>
                                      val offset = t.second
                                      next_cell - offset == cursor // check if this input gets the cursor to the next cell
                                   }.head.first
        cursor = next_cell

        sleep(wait_time) // better visualization
        resume(working_input_option.key)
      }

      def updateGrid(grid, viz_grid, borders) = {
        last_grid = grid
        last_viz_grid = viz_grid

        println(Screen::clear())
        println(show(last_viz_grid))

        if(path.isEmpty) {
          cursor = last_grid.findStart()

          with on[MissingValue].panic(); // when no path is found
          path = findWorkingPath(last_grid, borders).value
        }

        resume(())
      }

      def gameWon(msg) = {
        println(msg)
      }
  }
}

def testSuite(): Bool = suite("games/zip") {

  test("generatePaths2x2") {
    assertEqual(gamegrid::init(2, 2, EMPTY_CELL).generatePaths((0,0)).size,
                2) // verified
  }

  test("generatePaths3x3") {
    assertEqual(gamegrid::init(3, 3, EMPTY_CELL).generatePaths((0,0)).size,
                8) // verified
  }

  test("generatePaths4x4") {
    assertFalse(gamegrid::init(4, 4, EMPTY_CELL).generatePaths((0,0)).isEmpty)
  }

  test("generatePaths5x5") {
    assertFalse(gamegrid::init(5, 5, EMPTY_CELL).generatePaths((0,0)).isEmpty)
  }

  test("generatePaths3x3Middle") {
    assertEqual(gamegrid::init(3, 3, EMPTY_CELL).generatePaths((1,1)).size,
                8) // verified
  }

  test("generateSinglePath") {
    val all_paths_from_00 = [[(0,0), (0, 1), (1, 1), (1, 0)],
                             [(0, 0), (1, 0), (1, 1), (0, 1)]]


    def equals(p1: List[Vec2i], p2: List[Vec2i]): Bool / {} = {
      if (p1.size != p2.size) {false}
      else {
        zip(p1, p2).all {t => t.first.vec2i::equals(t.second)}
      }
    }

    var res = false
    with minstd(1234);
    gamegrid::init(2, 2, EMPTY_CELL).generateSinglePath((0,0)) match {
      case None() => res = false
      case Some(m) => {
        val p = m.extractPath()
        res = all_paths_from_00.contains(p) {(a, b) => a.equals(b)}
      }
    }

    assertTrue(res)
  }

  test("findStart") {
    assertEqual(Gamegrid(2, 2, fromList([Cell(Pathelement(1)), Cell(Pathelement(2)), Cell(Pathelement(4)), Cell(Pathelement(3))])).findStart(),
                (0, 0))
  }

  test("extractPath") {
    assertEqual(Gamegrid(2, 2, fromList([Cell(Pathelement(1)), Cell(Pathelement(2)), Cell(Pathelement(4)), Cell(Pathelement(3))])).extractPath(),
                [(0, 0), (1, 0), (1, 1), (0, 1)])
  }

  test("generateAllBorders2x2") {
    var m = gamegrid::init(2, 2, EMPTY_CELL)
    var p = [(0, 0), (1, 0), (1, 1), (0, 1)]

    assertEqual(generateAllBordersFromPath(m, p),
                [Border((0, 0),(0, 1))])
  }

  test("generateAllBorders3x3") {
    var m = gamegrid::init(3, 3, EMPTY_CELL)
    var p = [(0, 0), (1, 0), (2, 0), (2, 1), (1, 1), (0, 1), (0, 2), (1, 2), (2, 2)]

    assertEqual(generateAllBordersFromPath(m, p),
                [Border((2, 1),(2, 2)),
                 Border((1, 1),(1, 2)),
                 Border((1, 0), (1, 1)),
                 Border((0, 0), (0, 1)),
                 ])
  }

  test("show_maze") { // TODO: Rename function
    val m = Gamegrid(2, 2, fromList([Cell(Pathelement(1)), Cell(Pathelement(2)),    // 1 2
                                     Cell(Pathelement(4)), EMPTY_CELL]))            // 4 .

    val p_complete = [(0, 0), (1, 0), (1, 1), (0, 1)]
    val p_current = [(0, 0), (1, 0)]

    val borders = generateAllBordersFromPath(m, p_complete)

    val s_1 = "\u001b[31m" ++ Escape::BLINK ++ "1" ++ Escape::RESET ++ Escape::RESET
    val s_2 = "\u001b[31m" ++ "2" ++ Escape::RESET
    val s_EMPTY = "."
    val s_4 = "4"
    val s_$ = "\u001b[31m" ++ "$" ++ Escape::RESET
    val s_BORDER = "\u001b[34m" ++ "-" ++ Escape::RESET

    assertEqual(show_maze(m, p_current, (0, 0), borders),
                Gamegrid(5, 5, fromList([" ", " ", " ", " ", " ",
                                         " ", s_1, s_$, s_2, " ",
                                         " ", s_BORDER, " ", " ", " ",
                                         " ", s_4, " ", s_EMPTY, " ",
                                         " ", " ", " ", " ", " "])))
               { (a,b) => gamegrid::equals(a, b) } // TODO: Check why this is necessary
               { a => gamegrid::show(a) }
  }

  test("isWinning") {
    val m = Gamegrid(2, 2, fromList([Cell(Pathelement(1)), Cell(Pathelement(2)),    // 1 2
                                     Cell(Pathelement(4)), Cell(Pathelement(3))]))  // 4 3

    val p = [(0,0), (1,0), (1,1), (0,1)]

    assertTrue(isWinning(m, p, [Border((0,0), (0,1))]))
  }

  test("isNotWinning") {
    val m = Gamegrid(3, 3, fromList([Cell(Pathelement(1)), Cell(Empty()), Cell(Empty()),    // 1 . .
                                     Cell(Empty()), Cell(Empty()), Cell(Empty()),           // . . .
                                     Cell(Empty()), Cell(Empty()), Cell(Pathelement(2))]))  // . . 2

    val p = [(0,0), (1,0), (2,0), (2,1), (1,1), (0,1), (0,2), (1,2), (2,2)]

    assertFalse(isWinning(m, p, [Border((0,0), (1,0))])) // Border blocks path
  }

  test("findWorkingPath") {
    val m = Gamegrid(3, 3, fromList([Cell(Pathelement(1)), Cell(Empty()), Cell(Empty()),    // 1 . .
                                     Cell(Empty()), Cell(Empty()), Cell(Empty()),           // . . .
                                     Cell(Empty()), Cell(Empty()), Cell(Pathelement(2))]))  // . . 2

    with on[MissingValue].panic();
    val p = findWorkingPath(m, [Border((0,0), (0,1))]).value
    val p_correct = [(0,0), (1,0), (2,0), (2,1), (1,1), (0,1), (0,2), (1,2), (2,2)]

    assertEqual(p, p_correct)
  }

  test("findNoWorkingPath") {
    val m = Gamegrid(3, 3, fromList([Cell(Pathelement(1)), Cell(Empty()), Cell(Empty()),    // 1 . .
                                     Cell(Empty()), Cell(Empty()), Cell(Empty()),           // . . .
                                     Cell(Empty()), Cell(Empty()), Cell(Pathelement(2))]))  // . . 2

    val p = findWorkingPath(m, [Border((0,0), (0,1)), // no path possible
                                Border((0,0), (1,0))])

    assertEqual(p, None())
  }
}
