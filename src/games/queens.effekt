module src/games/queens

import src/util/gamegrid
import tty
import random
import bench
import test


type Status {
  Queen();
  Empty();
  Crossed();
}

def show(s: Status): String / {} = {
  s match {
    case Queen() => "â™•"
    case Empty() => "O"
    case Crossed() => "X"
  }
}

record Region(id: Int, color: String)

val REGIONS: List[Region] = [Region(0, "\u001b[31m"),
                             Region(1, "\u001b[32m"),
                             Region(2, "\u001b[33m"),
                             Region(3, "\u001b[34m"),
                             Region(4, "\u001b[35m"),
                             Region(5, "\u001b[36m"),
                             Region(6, "\u001b[30m"),
                             ]

record Cell(status: Status, reg: Region)
val EMPTY_CELL = Cell(Empty(), Region(-1, "\u001b[37m")) // TODO: Fix this

def isQueenCell(c: Cell): Bool / {} = {
  c.status match {
    case Queen() => true
    case _ => false
  }}

def isValidQueenPlacement(grid: Gamegrid[Cell], col: Int, row: Int): Bool / {} = {
  with on[OutOfBounds].panic;
  // Checking surrounding 8 cells if they already contain a queen
  val surr_cells = [(col, row - 1), (col + 1, row - 1), (col + 1, row),
                    (col + 1, row + 1), (col, row + 1), (col - 1, row + 1),
                    (col - 1, row), (col - 1, row - 1)] // all 8 adjacent cells
                    .filter {t => (t.first > 0 && t.first < grid.width &&
                                   t.second > 0 || t.second < grid.height)} // filter out overlaps
                    .map {t => grid.get(t.first, t.second)}

  // Checking all cells in the same row
  val horizontal_cells = (list::collect[Int] {range(0, col)}).append(
                          list::collect[Int] {range(col + 1, grid.width)})
                         .map {x => grid.get(x, row)}
  
  // Checking all cells in the same column
  val vertical_cells = (list::collect[Int] {range(0, row)}).append(
                        list::collect[Int] {range(row + 1, grid.height)})
                       .map {y => grid.get(col, y)}

  val mytest = [(col, row - 1), (col + 1, row - 1), (col + 1, row),
                    (col + 1, row + 1), (col, row + 1), (col - 1, row + 1),
                    (col - 1, row), (col - 1, row - 1)]

  surr_cells.append(horizontal_cells).append(vertical_cells).all {x => not(isQueenCell(x))} // if any queen cell is nearby, dismiss
}


def placeRegions(grid: Gamegrid[Cell]): Gamegrid[Cell] / {} = {
  val size = grid.width
  var populated_grid = grid

  // Mapping each region to its own column
  var available_columns: List[Int] = build(size) {x => x} // each region must have its queen in one unique column
  val used_regions = REGIONS.take(size)

  minstd(timestamp()) {
    used_regions.foreach[Region] { reg =>
      val col_index = randomInt(0, available_columns.size() - 1)

      with on[OutOfBounds].panic;
      val col = available_columns.get(col_index)
      val row = randomInt(0, size - 1)

      val cell = Cell(Queen(), reg) // Queen-Cell with current region

      with on[OutOfBounds].panic; // should not happen
      populated_grid = populated_grid.set(col, row, cell)

      available_columns = available_columns.deleteAt(col_index) // removing column the queen was placed at
    }
  }
  populated_grid
}

def generateGame(size: Int): Gamegrid[Cell] / {} = {
  val num_regions = size // this is trivial
  var board = gamegrid::init(size, size, EMPTY_CELL)

  board = board.placeRegions()
  board
}

def show_board(b: Gamegrid[Cell]): String = {
  show(
    b.map[Cell, String]{c => c.reg.color ++ show(c.status) ++ Escape::RESET}
  )
}

def main() = {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL])
    println(board.isValidQueenPlacement(0, 2))

    with on[OutOfBounds].panic;
    println(isQueenCell(board.get(0, 0)))
}

def testSuite(): Bool = suite("games/queens") {

  test("isQueen") {
    assertTrue(isQueenCell(Cell(Queen(), Region(0, "\u001b[31m"))))
  }

  test("isNotQueen") {
    assertFalse(isQueenCell(Cell(Empty(), Region(0, "\u001b[31m"))))
  }

  test("isNotQueen2") {
    assertFalse(isQueenCell(Cell(Crossed(), Region(0, "\u001b[31m"))))
  }

  test("validQueenPlacement") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL])
    assertTrue(board.isValidQueenPlacement(2, 2))
  }

  test("invalidQueenPlacementVert") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL])
    assertFalse(board.isValidQueenPlacement(0, 2))
  }

  test("invalidQueenPlacementHorizontal") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL])
    assertFalse(board.isValidQueenPlacement(2, 0))
  }

  test("invalidQueenPlacementDiag") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL])
    assertFalse(board.isValidQueenPlacement(1, 1))
  }
}
