module src/games/queens

import src/util/gamegrid
import src/util/vec2i
import src/util/randomUtil
import src/util/gamestate

import tty
import random
import bench
import test
import set


type Status {
  Queen();
  Empty();
  Crossed();
}

def show(s: Status): String / {} = {
  s match {
    case Queen() => "â™•"
    case Empty() => "O"
    case Crossed() => "X"
  }
}

record Region(id: Int, color: String)

val REGIONS: List[Region] = [Region(0, "\u001b[31m"),
                             Region(1, "\u001b[32m"),
                             Region(2, "\u001b[33m"),
                             Region(3, "\u001b[34m"),
                             Region(4, "\u001b[35m"),
                             Region(5, "\u001b[36m"),
                             Region(6, "\u001b[30m"),
                             ]

record Cell(status: Status, reg: Region)
val DEFAULT_CELL = Cell(Empty(), Region(-1, "\u001b[37m")) // TODO: Fix this

def isQueenCell(c: Cell): Bool / {} = {
  c.status match {
    case Queen() => true
    case _ => false
  }}

def isDefaultCell(c: Cell): Bool / {} = {
  c.reg.id == -1
}

type Board = Gamegrid[Cell]

def isValidQueenPlacement(board: Board, v: Vec2i): Bool / {} = {
  // Checking surrounding 8 cells if they already contain a queen
  val surr_cells = board.surroundingCells8(v)

  // Checking all cells in the same row
  val horizontal_cells = (list::collect[Int] {range(0, v.x)}).append(
                          list::collect[Int] {range(v.x + 1, board.width)})
                         .map {x => board.get((x, v.y))}
  
  // Checking all cells in the same column
  val vertical_cells = (list::collect[Int] {range(0, v.y)}).append(
                        list::collect[Int] {range(v.y + 1, board.height)})
                       .map {y => board.get((v.x, y))}

  surr_cells.append(horizontal_cells).append(vertical_cells).all {x => not(isQueenCell(x))} // if any queen cell is nearby, dismiss
}


interface Search {
  def pickRow(width: Int): Int
  def fail(): Nothing
}

// TODO: Shuffle regions around somehow
def placeNQueens(board: Board): List[Board] / {} = {
  try {
    var region_index = 0
    val columns = list::build(board.width) {x => x}
    var new_board = board.copy()

    columns.foreach {col =>
      var row = do pickRow(board.height)

      with on[OutOfBounds].panic();
      val reg = REGIONS.get(region_index)

      val cell = Cell(Queen(), reg)


      if(new_board.isValidQueenPlacement((col, row))) {
        new_board = new_board.setCopy((col, row), cell)
        region_index = region_index + 1
      }
      else {
        do fail()
      }
    }

    [new_board]
  } with Search {
      def pickRow(width) = {
        var boards: List[Board] = []

        val rows = list::build(board.height) {y => y}
        rows.foreach {row =>
          boards = resume(row).append(boards)
        }
        boards
      }
      def fail() = {[]}
  }
}

// TODO: Use sets, or arrays, just not lists
def expandRegions(board: Board): Unit / {random} = {
  type Expansion = (Vec2i, Region) // Coordinates and what the target Region would be (if expended)
  exhaustively {
    // List of all Cells and their coords, that can be spread from
    var spreadableCells: Array[(Vec2i, Cell)]= board.mapWithIndex {(a, b) => (a, b)}
                                                       .grid.filtered {t => t.second.isDefaultCell.not() &&
                                                                          board.surroundingCells4(t.first).any {isDefaultCell}}

    if(spreadableCells.size == 0) {
      do stop()
    }

    // Getting all neighbouring cells that are candidates for expansion
    var expansions: List[Expansion] = []
    spreadableCells.foreach { t =>
      val surr_cells = board.surroundingCells4WithIndices(t.first)
                                .filter {t_ => t_.second.isDefaultCell}
                                .map {t_ => (t_.first, t.second.reg)}

      expansions = expansions.append(surr_cells)
    }

    val expansion = pickRandomElement(expansions)

    board.set(expansion.first, Cell(Empty(), expansion.second))
  }
}

def generateGame(size: Int): Board / {Exception[RuntimeError]} = {
  var board = gamegrid::init(size, size, DEFAULT_CELL)

  minstd(timestamp()) {
    var validBoards = board.placeNQueens()

    if(validBoards.isEmpty) {
      do raise(RuntimeError(), "Could not generate any boards for size " ++ show(size) ++ "x" ++ show(size) ++ "!")
    }

    board = pickRandomElement(validBoards)
    board.expandRegions()
  }

  board
}

def isWinning(board: Board): Bool / {} = {
  val num_queens = board.grid.count {c => c.isQueenCell()}

  // Checking if more than 1 queen is in each region
  var used_regions: Set[Int] = empty(box compareInt)
  board.grid.foreach { c =>
    if (c.isQueenCell()) {
      used_regions = used_regions.insert(c.reg.id)
    }
  }

  val allQueensValid = board.mapWithIndex{(v, c) => c.isQueenCell.not() ||
                                                       (c.isQueenCell && board.isValidQueenPlacement(v))}
                            .grid.all {b => b} // TODO: Fix

  (num_queens == board.width) && allQueensValid && (num_queens == used_regions.size)
}

def hideQueens(board: Board): Board / {} = {
  board.map{c => if(c.isQueenCell) {Cell(Empty(), c.reg)} else {c}} // replace Queen cells with cells of same region
}

def placeStatus(board: Board, s: Status, cursor: Vec2i): Unit / {} = {
    val current_region = board.get(cursor).reg
    board.set(cursor, Cell(s, current_region))
}

def addOntoIfInBound(v1: Vec2i, v2: Vec2i, board: Board): Vec2i / {} = {
  val v3 = v1 + v2
  if(board.isInBound(v3)) {
    v3
  }
  else {
    v1
  }
}

def gameloop(board: Board): Unit / {Gamestate} = {
  var cursor = (0, 0)
  var current_board = board

  val input_options = [
    InputOption("w", "Cursor up"),
    InputOption("s", "Cursor down"),
    InputOption("a", "Cursor left"),
    InputOption("d", "Cursor right"),
    InputOption("q", "Place Queen"),
    InputOption("o", "Reset cell"),
    InputOption("x", "Cross cell")
  ]

  loop() {{l: Control} =>
    // Sending current board to console
    do updateGrid(current_board.mapWithIndex[Cell, String]
                      {(v, c) => if (v.x == cursor.x && v.y == cursor.y) {Escape::BLINK ++ c.reg.color ++ show(c.status) ++ Escape::RESET}
                                    else {c.reg.color ++ show(c.status) ++ Escape::RESET}
                      }
                  )

    if(current_board.isWinning()) {
      l.break()
    }

    val input = do getUserInput(input_options)

    input match {
      case "w" => cursor = cursor.addOntoIfInBound((0,-1), current_board)
      case "a" => cursor = cursor.addOntoIfInBound((-1,0), current_board)
      case "s" => cursor = cursor.addOntoIfInBound((0,1), current_board)
      case "d" => cursor = cursor.addOntoIfInBound((1,0), current_board)
      case "q" => current_board.placeStatus(Queen(), cursor)
      case "x" => current_board.placeStatus(Crossed(), cursor)
      case "o" => current_board.placeStatus(Empty(), cursor)
      case _ => l.continue()
    }
  }

  do gameWon(
    """
 __     __                                  ____                              _
 \ \   / /                                 / __ \                            | |
  \ \_/ /__  _   _  __      _____  _ __   | |  | |_   _  ___  ___ _ __  ___  | |
   \   / _ \| | | | \ \ /\ / / _ \| '_ \  | |  | | | | |/ _ \/ _ \ '_ \/ __| | |
    | | (_) | |_| |  \ V  V / (_) | | | | | |__| | |_| |  __/  __/ | | \__ \ |_|
    |_|\___/ \__,_|   \_/\_/ \___/|_| |_|  \___\_\\__,_|\___|\___|_| |_|___/ (_)

    """
    )
}


def testSuite(): Bool = suite("games/queens") {

  test("isQueen") {
    assertTrue(isQueenCell(Cell(Queen(), Region(0, "\u001b[31m"))))
  }

  test("isNotQueen") {
    assertFalse(isQueenCell(Cell(Empty(), Region(0, "\u001b[31m"))))
  }

  test("isNotQueen2") {
    assertFalse(isQueenCell(Cell(Crossed(), Region(0, "\u001b[31m"))))
  }

  test("validQueenPlacement") {
    var board = Gamegrid(3, 3, fromList([Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                              DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                              DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL]))
    assertTrue(board.isValidQueenPlacement((2, 2)))
  }

  test("invalidQueenPlacementVert") {
    var board = Gamegrid(3, 3, fromList([Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL]))
    assertFalse(board.isValidQueenPlacement((0, 2)))
  }

  test("invalidQueenPlacementHorizontal") {
    var board = Gamegrid(3, 3, fromList([Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                         DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                         DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL]))
    assertFalse(board.isValidQueenPlacement((2, 0)))
  }

  test("invalidQueenPlacementDiag") {
    var board = Gamegrid(3, 3, fromList([Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                              DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                              DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL]))
    assertFalse(board.isValidQueenPlacement((1, 1)))
  }

  test("validQueenPlacement1x1") {
    var board = Gamegrid(1, 1, fromList([DEFAULT_CELL]))
    assertTrue(board.isValidQueenPlacement((0, 0)))
  }

  test("queensPlacement1x1") {
    assertEqual(gamegrid::init(1, 1, DEFAULT_CELL).placeNQueens().size,
                1)
  }

  test("queensPlacement2x2") {
    assertEqual(gamegrid::init(2, 2, DEFAULT_CELL).placeNQueens(), // Queens not possibl on 2x2
                Nil())
  }

  test("queensPlacement3x3") {
    assertEqual(gamegrid::init(3, 3, DEFAULT_CELL).placeNQueens(), // Queens not possibl on 3x3
                Nil())
  }

  test("queensPlacement4x4") {
    assertEqual(gamegrid::init(4, 4, DEFAULT_CELL).placeNQueens().size, // Only solutions for 4x4
                2)
  }

  test("4QueensFor4x4") {
    with on[MissingValue].panic()
    val board = gamegrid::init(4, 4, DEFAULT_CELL).placeNQueens().head()

    assertEqual(board.grid.count{isQueenCell},
                4)
  }

  test("5QueensFor5x5") {
    with on[MissingValue].panic()
    val board = gamegrid::init(5, 5, DEFAULT_CELL).placeNQueens().head()

    assertEqual(board.grid.count{isQueenCell},
                5)
  }

  test("expandRegions4x4") {
    with on[MissingValue].panic()
    val board = gamegrid::init(4, 4, DEFAULT_CELL).placeNQueens().head()

    with minstd(timestamp());
    board.expandRegions()
    assertFalse(board.grid.any{isDefaultCell}) // No more default cells after expaning
  }

  test("isWinningByGeneration") {
    with on[MissingValue].panic()
    val board = gamegrid::init(4, 4, DEFAULT_CELL).placeNQueens().head()

    with minstd(timestamp());
    board.expandRegions()

    assertTrue(board.isWinning())
  }

  test("isWinning") {
    var board = Gamegrid(4, 4, fromList([Cell(Empty(), Region(1, "\u001b[31m")), Cell(Empty(), Region(1, "\u001b[31m")), // AAAA
                                         Cell(Empty(), Region(1, "\u001b[31m")), Cell(Empty(), Region(1, "\u001b[31m")), // BBBB
                                         Cell(Empty(), Region(2, "\u001b[31m")), Cell(Empty(), Region(2, "\u001b[31m")), // CCCC
                                         Cell(Empty(), Region(2, "\u001b[31m")), Cell(Empty(), Region(2, "\u001b[31m")), // DDDD
                                         Cell(Empty(), Region(3, "\u001b[31m")), Cell(Empty(), Region(3, "\u001b[31m")),
                                         Cell(Empty(), Region(3, "\u001b[31m")), Cell(Empty(), Region(3, "\u001b[31m")),
                                         Cell(Empty(), Region(4, "\u001b[31m")), Cell(Empty(), Region(4, "\u001b[31m")),
                                         Cell(Empty(), Region(4, "\u001b[31m")), Cell(Empty(), Region(4, "\u001b[31m"))]))

    board.placeStatus(Queen(), (0, 1))
    board.placeStatus(Queen(), (1, 3))
    board.placeStatus(Queen(), (2, 0))
    board.placeStatus(Queen(), (3, 2))

    assertTrue(board.isWinning())
  }

  test("isNotWinningNotEnoughQueen") {
    var board = Gamegrid(4, 4, fromList([Cell(Empty(), Region(1, "\u001b[31m")), Cell(Empty(), Region(1, "\u001b[31m")), // AAAA
                                         Cell(Empty(), Region(1, "\u001b[31m")), Cell(Empty(), Region(1, "\u001b[31m")), // BBBB
                                         Cell(Empty(), Region(2, "\u001b[31m")), Cell(Empty(), Region(2, "\u001b[31m")), // CCCC
                                         Cell(Empty(), Region(2, "\u001b[31m")), Cell(Empty(), Region(2, "\u001b[31m")), // DDDD
                                         Cell(Empty(), Region(3, "\u001b[31m")), Cell(Empty(), Region(3, "\u001b[31m")),
                                         Cell(Empty(), Region(3, "\u001b[31m")), Cell(Empty(), Region(3, "\u001b[31m")),
                                         Cell(Empty(), Region(4, "\u001b[31m")), Cell(Empty(), Region(4, "\u001b[31m")),
                                         Cell(Empty(), Region(4, "\u001b[31m")), Cell(Empty(), Region(4, "\u001b[31m"))]))

    board.placeStatus(Queen(), (0, 1))
    board.placeStatus(Queen(), (1, 3))
    board.placeStatus(Queen(), (2, 0))

    assertFalse(board.isWinning())
  }

  test("isNotWinningMultipleQueensInRegion") {
    var board = Gamegrid(4, 4, fromList([Cell(Empty(), Region(1, "\u001b[31m")), Cell(Empty(), Region(1, "\u001b[31m")), // AAAA
                                         Cell(Empty(), Region(1, "\u001b[31m")), Cell(Empty(), Region(1, "\u001b[31m")), // BBCC
                                         Cell(Empty(), Region(2, "\u001b[31m")), Cell(Empty(), Region(2, "\u001b[31m")), // BBDD
                                         Cell(Empty(), Region(3, "\u001b[31m")), Cell(Empty(), Region(3, "\u001b[31m")), // BBDD
                                         Cell(Empty(), Region(2, "\u001b[31m")), Cell(Empty(), Region(2, "\u001b[31m")),
                                         Cell(Empty(), Region(4, "\u001b[31m")), Cell(Empty(), Region(4, "\u001b[31m")),
                                         Cell(Empty(), Region(2, "\u001b[31m")), Cell(Empty(), Region(2, "\u001b[31m")),
                                         Cell(Empty(), Region(4, "\u001b[31m")), Cell(Empty(), Region(4, "\u001b[31m"))]))

    board.placeStatus(Queen(), (0, 1)) // 2 Queen in same region B
    board.placeStatus(Queen(), (1, 3)) // -^^
    board.placeStatus(Queen(), (2, 0))
    board.placeStatus(Queen(), (3, 2))

    assertFalse(board.isWinning())
  }

  test("isNotWinning") {
    var board = Gamegrid(4, 4, fromList([Cell(Empty(), Region(1, "\u001b[31m")), Cell(Empty(), Region(1, "\u001b[31m")), // AAAA
                                         Cell(Empty(), Region(1, "\u001b[31m")), Cell(Empty(), Region(1, "\u001b[31m")), // BBBB
                                         Cell(Empty(), Region(2, "\u001b[31m")), Cell(Empty(), Region(2, "\u001b[31m")), // CCCC
                                         Cell(Empty(), Region(2, "\u001b[31m")), Cell(Empty(), Region(2, "\u001b[31m")), // DDDD
                                         Cell(Empty(), Region(3, "\u001b[31m")), Cell(Empty(), Region(3, "\u001b[31m")),
                                         Cell(Empty(), Region(3, "\u001b[31m")), Cell(Empty(), Region(3, "\u001b[31m")),
                                         Cell(Empty(), Region(4, "\u001b[31m")), Cell(Empty(), Region(4, "\u001b[31m")),
                                         Cell(Empty(), Region(4, "\u001b[31m")), Cell(Empty(), Region(4, "\u001b[31m"))]))

    board.placeStatus(Queen(), (0, 1))
    board.placeStatus(Queen(), (1, 1)) // Same column
    board.placeStatus(Queen(), (2, 0))
    board.placeStatus(Queen(), (3, 2))

    assertFalse(board.isWinning())
  }
}
