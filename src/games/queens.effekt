module src/games/queens

import src/util/gamegrid
import src/util/randomUtil

import tty
import random
import bench
import test


type Status {
  Queen();
  Empty();
  Crossed();
}

def show(s: Status): String / {} = {
  s match {
    case Queen() => "â™•"
    case Empty() => "O"
    case Crossed() => "X"
  }
}

record Region(id: Int, color: String)

val REGIONS: List[Region] = [Region(0, "\u001b[31m"),
                             Region(1, "\u001b[32m"),
                             Region(2, "\u001b[33m"),
                             Region(3, "\u001b[34m"),
                             Region(4, "\u001b[35m"),
                             Region(5, "\u001b[36m"),
                             Region(6, "\u001b[30m"),
                             ]

record Cell(status: Status, reg: Region)
val DEFAULT_CELL = Cell(Empty(), Region(-1, "\u001b[37m")) // TODO: Fix this

def isQueenCell(c: Cell): Bool / {} = {
  c.status match {
    case Queen() => true
    case _ => false
  }}

def isDefaultCell(c: Cell): Bool / {} = {
  c.reg.id == -1
}

type Board = Gamegrid[Cell]

def isValidQueenPlacement(board: Board, col: Int, row: Int): Bool / {} = {
  // Checking surrounding 8 cells if they already contain a queen
  val surr_cells = board.surroundingCells8(col, row)

  // Checking all cells in the same row
  val horizontal_cells = (list::collect[Int] {range(0, col)}).append(
                          list::collect[Int] {range(col + 1, board.width)})
                         .map {x => board.get(x, row)}
  
  // Checking all cells in the same column
  val vertical_cells = (list::collect[Int] {range(0, row)}).append(
                        list::collect[Int] {range(row + 1, board.height)})
                       .map {y => board.get(col, y)}

  surr_cells.append(horizontal_cells).append(vertical_cells).all {x => not(isQueenCell(x))} // if any queen cell is nearby, dismiss
}

// Checks if all queens that are placed are placed valid
def isValidBoard(board: Board): Bool / {} = {
  board.mapWithIndex[Cell, Bool] {(x, y, c) =>
                                   c.isQueenCell && board.isValidQueenPlacement(x, y)}
       .grid.all {b => b} // TODO: Fix
}


interface Search {
  def pickRow(width: Int): Int
  def fail(): Nothing
}

// TODO: Verify that it works
// TODO: Shuffle regions around somehow
def placeNQueens(board: Board): List[Board] / {} = {
  try {
    var region_index = 0
    val columns = list::build(board.width) {x => x}
    var new_board = board

    columns.foreach {col =>
      var row = do pickRow(board.width)

      with on[OutOfBounds].panic();
      val reg = REGIONS.get(region_index)

      val cell = Cell(Queen(), reg)


      if(new_board.isValidQueenPlacement(col, row)) {
        new_board = new_board.set(col, row, cell)
        region_index = region_index + 1
      }
      else {
        do fail()
      }
    }

    [new_board]
  } with Search {
      def pickRow(width) = {
        var boards: List[Board] = []

        val rows = list::build(board.height) {y => y}
        rows.foreach {row =>
          boards = resume(row).append(boards)
        }
        boards
      }
      def fail() = {[]}
  }
}


def expandRegions(board: Board): Board / {random} = {
  type Expansion = Tuple3[Int, Int, Region] // Coordinates and what the target Region would be (if expended)
  var new_board = board

  exhaustively {
    var spreadableCells = new_board.mapWithIndex {(x, y, c) => (x, y, c)}
                                   .grid.filter {t => t.third.isDefaultCell.not() &&
                                                      new_board.surroundingCells4(t.first, t.second).any {isDefaultCell}} // can only expand if there are any free cells

    if(spreadableCells.isEmpty()) {
      do stop()
    }

    var expansions: List[Expansion] = spreadableCells.flatMap {t => new_board.surroundingCells4WithIndices(t.first, t.second)
                                                                             .filter {t_ => t_.third.isDefaultCell}
                                                                             .map {t_ => (t_.first, t_.second, t.third.reg)} }

    with on[OutOfBounds].panic();
    val expansion = expansions.get(randomInt(0, expansions.size - 1))

    new_board = new_board.set(expansion.first, expansion.second, Cell(Empty(), expansion.third))
  }

  new_board
}

def generateGame(size: Int): Board / {} = {
  var board = gamegrid::init(size, size, DEFAULT_CELL)

  minstd(timestamp()) {
    var validBoards = board.placeNQueens()

    board = pickRandomElement(validBoards)
    board = board.expandRegions()
  }

  board
}

def show_board(b: Board): String = {
  show(
    b.map[Cell, String]{c => c.reg.color ++ show(c.status) ++ Escape::RESET}
  )
}

def main() = {
  val b = generateGame(6)
  println(show_board(b))
}

def testSuite(): Bool = suite("games/queens") {

  test("isQueen") {
    assertTrue(isQueenCell(Cell(Queen(), Region(0, "\u001b[31m"))))
  }

  test("isNotQueen") {
    assertFalse(isQueenCell(Cell(Empty(), Region(0, "\u001b[31m"))))
  }

  test("isNotQueen2") {
    assertFalse(isQueenCell(Cell(Crossed(), Region(0, "\u001b[31m"))))
  }

  test("validQueenPlacement") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL])
    assertTrue(board.isValidQueenPlacement(2, 2))
  }

  test("invalidQueenPlacementVert") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL])
    assertFalse(board.isValidQueenPlacement(0, 2))
  }

  test("invalidQueenPlacementHorizontal") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL])
    assertFalse(board.isValidQueenPlacement(2, 0))
  }

  test("invalidQueenPlacementDiag") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL])
    assertFalse(board.isValidQueenPlacement(1, 1))
  }
}
