module src/games/queens

import src/util/gamegrid
import tty
import random
import bench
import test


type Status {
  Queen();
  Empty();
  Crossed();
}

def show(s: Status): String / {} = {
  s match {
    case Queen() => "â™•"
    case Empty() => "O"
    case Crossed() => "X"
  }
}

record Region(id: Int, color: String)

val REGIONS: List[Region] = [Region(0, "\u001b[31m"),
                             Region(1, "\u001b[32m"),
                             Region(2, "\u001b[33m"),
                             Region(3, "\u001b[34m"),
                             Region(4, "\u001b[35m"),
                             Region(5, "\u001b[36m"),
                             Region(6, "\u001b[30m"),
                             ]

record Cell(status: Status, reg: Region)
val EMPTY_CELL = Cell(Empty(), Region(-1, "\u001b[37m")) // TODO: Fix this

def isQueenCell(c: Cell): Bool / {} = {
  c.status match {
    case Queen() => true
    case _ => false
  }}

type Board = Gamegrid[Cell]

def isValidQueenPlacement(board: Board, col: Int, row: Int): Bool / {} = {
  // Checking surrounding 8 cells if they already contain a queen
  val surr_cells = [(col, row - 1), (col + 1, row - 1), (col + 1, row),
                    (col + 1, row + 1), (col, row + 1), (col - 1, row + 1),
                    (col - 1, row), (col - 1, row - 1)] // all 8 adjacent cells
                    .filter {t => (t.first >= 0 && t.first < board.width &&
                                   t.second >= 0 && t.second < board.height)} // filter out overlaps
                    .map {t => board.get(t.first, t.second)}

  // Checking all cells in the same row
  val horizontal_cells = (list::collect[Int] {range(0, col)}).append(
                          list::collect[Int] {range(col + 1, board.width)})
                         .map {x => board.get(x, row)}
  
  // Checking all cells in the same column
  val vertical_cells = (list::collect[Int] {range(0, row)}).append(
                        list::collect[Int] {range(row + 1, board.height)})
                       .map {y => board.get(col, y)}

  surr_cells.append(horizontal_cells).append(vertical_cells).all {x => not(isQueenCell(x))} // if any queen cell is nearby, dismiss
}

// Checks if all queens that are placed are placed valid
def isValidBoard(board: Board): Bool / {} = {
  board.mapWithIndex[Cell, Bool] {(x, y, c) =>
                                   c.isQueenCell && board.isValidQueenPlacement(x, y)}
       .grid.all {b => b} // TODO: Fix
}


interface Search {
  def pickRow(width: Int): Int
  def fail(): Nothing
}

// TODO: Verify that it works
// TODO: Shuffle regions around somehow
def placeNQueens(board: Board): List[Board] / {} = {
  try {
    var region_index = 0
    val columns = list::build(board.width) {x => x}
    var new_board = board

    columns.foreach {col =>
      var row = do pickRow(board.width)

      with on[OutOfBounds].panic();
      val reg = REGIONS.get(region_index)

      val cell = Cell(Queen(), reg)


      if(new_board.isValidQueenPlacement(col, row)) {
        new_board = new_board.set(col, row, cell)
        region_index = region_index + 1
      }
      else {
        do fail()
      }
    }

    [new_board]
  } with Search {
      def pickRow(width) = {
        var boards: List[Board] = []

        val rows = list::build(board.height) {y => y}
        rows.foreach {row =>
          boards = resume(row).append(boards)
        }
        boards
      }
      def fail() = {[]}
  }
}

def expandRegions(board: Board): Board / {} = {
  board
}

def generateGame(size: Int): Board / {} = {
  val num_regions = size // this is trivial
  var board = gamegrid::init(size, size, EMPTY_CELL)

  // Placing Queens on board
  var validBoards = board.placeNQueens()
  minstd(timestamp()) { // TODO: Use with here?
    with on[OutOfBounds].panic();
    board = validBoards.get(randomInt(0, validBoards.size - 1))
  }

  // Expanding Regions
  board = board.expandRegions()
  board
}

def show_board(b: Board): String = {
  show(
    b.map[Cell, String]{c => c.reg.color ++ show(c.status) ++ Escape::RESET}
  )
}

def main() = {
  val b = generateGame(7)
  println(show_board(b))
}

def testSuite(): Bool = suite("games/queens") {

  test("isQueen") {
    assertTrue(isQueenCell(Cell(Queen(), Region(0, "\u001b[31m"))))
  }

  test("isNotQueen") {
    assertFalse(isQueenCell(Cell(Empty(), Region(0, "\u001b[31m"))))
  }

  test("isNotQueen2") {
    assertFalse(isQueenCell(Cell(Crossed(), Region(0, "\u001b[31m"))))
  }

  test("validQueenPlacement") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL])
    assertTrue(board.isValidQueenPlacement(2, 2))
  }

  test("invalidQueenPlacementVert") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL])
    assertFalse(board.isValidQueenPlacement(0, 2))
  }

  test("invalidQueenPlacementHorizontal") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL])
    assertFalse(board.isValidQueenPlacement(2, 0))
  }

  test("invalidQueenPlacementDiag") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL,
                                EMPTY_CELL, EMPTY_CELL, EMPTY_CELL])
    assertFalse(board.isValidQueenPlacement(1, 1))
  }
}
