module src/games/queens

import src/util/gamegrid
import src/util/vec2i
import src/util/randomUtil
import src/util/gamestate

import tty
import random
import bench
import test


type Status {
  Queen();
  Empty();
  Crossed();
}

def show(s: Status): String / {} = {
  s match {
    case Queen() => "â™•"
    case Empty() => "O"
    case Crossed() => "X"
  }
}

record Region(id: Int, color: String)

val REGIONS: List[Region] = [Region(0, "\u001b[31m"),
                             Region(1, "\u001b[32m"),
                             Region(2, "\u001b[33m"),
                             Region(3, "\u001b[34m"),
                             Region(4, "\u001b[35m"),
                             Region(5, "\u001b[36m"),
                             Region(6, "\u001b[30m"),
                             ]

record Cell(status: Status, reg: Region)
val DEFAULT_CELL = Cell(Empty(), Region(-1, "\u001b[37m")) // TODO: Fix this

def isQueenCell(c: Cell): Bool / {} = {
  c.status match {
    case Queen() => true
    case _ => false
  }}

def isDefaultCell(c: Cell): Bool / {} = {
  c.reg.id == -1
}

type Board = Gamegrid[Cell]

def isValidQueenPlacement(board: Board, v: Vec2i): Bool / {} = {
  // Checking surrounding 8 cells if they already contain a queen
  val surr_cells = board.surroundingCells8(v)

  // Checking all cells in the same row
  val horizontal_cells = (list::collect[Int] {range(0, v.x)}).append(
                          list::collect[Int] {range(v.x + 1, board.width)})
                         .map {x => board.get((x, v.y))}
  
  // Checking all cells in the same column
  val vertical_cells = (list::collect[Int] {range(0, v.y)}).append(
                        list::collect[Int] {range(v.y + 1, board.height)})
                       .map {y => board.get((v.x, y))}

  surr_cells.append(horizontal_cells).append(vertical_cells).all {x => not(isQueenCell(x))} // if any queen cell is nearby, dismiss
}


interface Search {
  def pickRow(width: Int): Int
  def fail(): Nothing
}

// TODO: Verify that it works
// TODO: Shuffle regions around somehow
def placeNQueens(board: Board): List[Board] / {} = {
  try {
    var region_index = 0
    val columns = list::build(board.width) {x => x}
    var new_board = board

    columns.foreach {col =>
      var row = do pickRow(board.width)

      with on[OutOfBounds].panic();
      val reg = REGIONS.get(region_index)

      val cell = Cell(Queen(), reg)


      if(new_board.isValidQueenPlacement((col, row))) {
        new_board = new_board.set((col, row), cell)
        region_index = region_index + 1
      }
      else {
        do fail()
      }
    }

    [new_board]
  } with Search {
      def pickRow(width) = {
        var boards: List[Board] = []

        val rows = list::build(board.height) {y => y}
        rows.foreach {row =>
          boards = resume(row).append(boards)
        }
        boards
      }
      def fail() = {[]}
  }
}


def expandRegions(board: Board): Board / {random} = {
  type Expansion = (Vec2i, Region) // Coordinates and what the target Region would be (if expended)
  var new_board = board

  exhaustively {
    var spreadableCells = new_board.mapWithIndex {(v, c) => (v, c)}
                                   .grid.filter {t => t.second.isDefaultCell.not() &&
                                                      new_board.surroundingCells4(t.first).any {isDefaultCell}} // can only expand if there are any free cells

    if(spreadableCells.isEmpty()) {
      do stop()
    }

    var expansions: List[Expansion] = spreadableCells.flatMap {t => 
                                                      new_board.surroundingCells4WithIndices(t.first)
                                                                             .filter {t_ => t_.second.isDefaultCell}
                                                                             .map {t_ => (t_.first, t_.second.reg)} }

    with on[OutOfBounds].panic();
    val expansion = expansions.get(randomInt(0, expansions.size - 1))

    new_board = new_board.set(expansion.first, Cell(Empty(), expansion.second))
  }

  new_board
}

def generateGame(size: Int): Board / {} = {
  var board = gamegrid::init(size, size, DEFAULT_CELL)

  minstd(timestamp()) {
    var validBoards = board.placeNQueens()

    board = pickRandomElement(validBoards)
    board = board.expandRegions()
  }

  board
}

def isWinning(board: Board): Bool / {} = {
  val num_queens = board.grid.count {c => c.isQueenCell()}

  val allQueensValid = board.mapWithIndex{(v, c) => c.isQueenCell.not() ||
                                                       (c.isQueenCell && board.isValidQueenPlacement(v))}
                            .grid.all {b => b} // TODO: Fix
  (num_queens == board.width) && allQueensValid
}

def hideQueens(board: Board): Board / {} = {
  board.map{c => if(c.isQueenCell) {Cell(Empty(), c.reg)} else {c}} // replace Queen cells with cells of same region
}

def gameloop(board: Board): Unit / {Gamestate} = {
  var cursor = (0, 0)
  var current_board = board

  val input_options = [
    InputOption("w", "Cursor up"),
    InputOption("s", "Cursor down"),
    InputOption("a", "Cursor left"),
    InputOption("d", "Cursor right"),
    InputOption("q", "Place Queen"),
    InputOption("o", "Reset cell"),
    InputOption("x", "Cross cell")
  ]

  exhaustively() {
    if(current_board.isWinning()) {
      do stop()
    }

    // Sending current board to console
    do updateGrid(current_board.mapWithIndex[Cell, String]
                      {(v, c) => if (v.x == cursor.x && v.y == cursor.y) {Escape::BLINK ++ c.reg.color ++ show(c.status) ++ Escape::RESET}
                                    else {c.reg.color ++ show(c.status) ++ Escape::RESET}
                      }
                  )

    // applying input of user
    var old_cursor = cursor // < In case the new coords are out of bound

    val input = do getUserInput(input_options)

    input match {
      case "w" => cursor = cursor - (0,1)
      case "a" => cursor = cursor - (1,0)
      case "s" => cursor = cursor + (0,1)
      case "d" => cursor = cursor + (1,0)
      case "q" => {
          // TODO: make placeQueen(x,y)
          val current_region = current_board.get(cursor).reg
          current_board = current_board.set(cursor, Cell(Queen(), current_region))
      }
      case "x" => {
          // TODO: make placeCross(x,y)
          val current_region = current_board.get(cursor).reg
          current_board = current_board.set(cursor, Cell(Crossed(), current_region))
      }
      case "o" => {
          // TODO: make placeEmpty(x,y)
          val current_region = current_board.get(cursor).reg
          current_board = current_board.set(cursor, Cell(Empty(), current_region))
      }
      case _ => println("Invalid Input!") // TODO: Fix this
    }

    // Resetting cursor if cursor got out of bound TODO: Maybe fix this by not allowing moving outside?
    if (current_board.isInBound(cursor).not()) {
      cursor = old_cursor
    }
  }

  do gameWon("You won Queens!") // TODO: Something pretty
}


// TODO: More tests about the gamegeneration
def testSuite(): Bool = suite("games/queens") {

  test("isQueen") {
    assertTrue(isQueenCell(Cell(Queen(), Region(0, "\u001b[31m"))))
  }

  test("isNotQueen") {
    assertFalse(isQueenCell(Cell(Empty(), Region(0, "\u001b[31m"))))
  }

  test("isNotQueen2") {
    assertFalse(isQueenCell(Cell(Crossed(), Region(0, "\u001b[31m"))))
  }

  test("validQueenPlacement") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL])
    assertTrue(board.isValidQueenPlacement((2, 2)))
  }

  test("invalidQueenPlacementVert") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL])
    assertFalse(board.isValidQueenPlacement((0, 2)))
  }

  test("invalidQueenPlacementHorizontal") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL])
    assertFalse(board.isValidQueenPlacement((2, 0)))
  }

  test("invalidQueenPlacementDiag") {
    var board = Gamegrid(3, 3, [Cell(Queen(), Region(0, "\u001b[31m")), DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL,
                                DEFAULT_CELL, DEFAULT_CELL, DEFAULT_CELL])
    assertFalse(board.isValidQueenPlacement((1, 1)))
  }
}
