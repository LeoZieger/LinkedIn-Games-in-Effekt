module src/util/gamegrid

import test
import src/util/vec2i
import array

// Grid of values, defined top left to bottom right
record Gamegrid[A](width: Int, height: Int, grid:Array[A])

def coordsToIndex(v: Vec2i, width: Int): Int = v.y * width + v.x
def indexToCoords(i: Int, width: Int): Vec2i / {} = (i.mod(width), i / width)

// Applies changes to actual grid
def set[A](grid: Gamegrid[A], v: Vec2i, a: A): Unit / {} = {
  with on[OutOfBounds].panic; // TODO: Maybe propagate
  val index = coordsToIndex((v.x, v.y), grid.width)

  grid.grid.set(index, a)
}

// Copies grid and applies changes to copy, returns copy
def setCopy[A](grid: Gamegrid[A], v: Vec2i, a: A): Gamegrid[A] / {} = {
  with on[OutOfBounds].panic; // TODO: Maybe propagate
  val index = coordsToIndex((v.x, v.y), grid.width)

  // TODO: Implement this without copying all the time, return Unit and change algorithms
  var new_arr = grid.grid.copy()
  new_arr.set(index, a)
  Gamegrid(grid.width, grid.height, new_arr)
}
def get[A](grid: Gamegrid[A], v: Vec2i): A / {} = {
  with on[OutOfBounds].panic; // TODO: Maybe propagate
  val index = coordsToIndex(v, grid.width)
  grid.grid.get(index)
}

// Initialize Gamegrid with one value
def init[A](width: Int, height: Int, a: A): Gamegrid[A] / {} = {
  Gamegrid(width, height, array(width * height, a))
}

// Initialize Gamegrid with individual values
def initWith[A](width: Int, height: Int) {f: Vec2i => A}: Gamegrid[A] / {} = {
  var grid: List[A] = []
  var index_x = 0
  var index_y = 0

  repeat(height) {
    repeat(width) {
      val a: A = f((index_x, index_y))
      grid = Cons(a,grid)
      index_x = index_x + 1
    }
    index_x = 0
    index_y = index_y + 1
  }

  grid = grid.reverse()

  Gamegrid(width, height, fromList(grid))
}


def show(grid: Gamegrid[String]): String / {} = {
  var index = 0
  var line = ""

  grid.grid.foreach {a =>
    if(index > grid.width - 1) {
      line = line ++ "\n"
      index = 0
    }

    line = line ++ a ++ " " // TODO: This might be wrong
    index = index + 1
  }
  line
}


def show(grid: Gamegrid[Int]): String / {} = {
  var index = 0
  var line = ""

  grid.grid.foreach {a =>
    if(index > grid.width - 1) {
      line = line ++ "\n"
      index = 0
    }

    line = line ++ show(a) ++ " " // TODO: This might be wrong
    index = index + 1
  }
  line
}


def map[A, B](grid: Gamegrid[A]) {f: A => B}: Gamegrid[B] = {
  Gamegrid(grid.width, grid.height, grid.grid.mapped {f}) // TODO: Maybe allow map and mapped in different functions?
}

def mapWithIndex[A, B](grid: Gamegrid[A]) {f: (Vec2i, A) => B}: Gamegrid[B] / {} = {

  val new_grid = grid.grid.toList.list::mapWithIndex[A, B]{(i, a) =>
                                                      val v = indexToCoords(i, grid.width) // transform index to coords
                                                      f(v, a) // and supply to coord-based function
                                                    }
  Gamegrid(grid.width, grid.height, fromList(new_grid)) // TODO: Dont convert to list
}


def isInBound[A](grid: Gamegrid[A], v: Vec2i): Bool / {} = {
  (v.x >= 0 && v.x < grid.width &&
   v.y >= 0 && v.y < grid.height)
}


def surroundingCells4[A](grid: Gamegrid[A] , v: Vec2i): List[A] / {} = {
  [(v.x, v.y - 1), (v.x + 1, v.y), (v.x, v.y + 1), (v.x - 1, v.y)]
  .filter {v => grid.isInBound(v)} // filter out overlaps
  .map {v => grid.get(v)}
}


def surroundingCells4WithIndices[A](grid: Gamegrid[A] , v: Vec2i): List[(Vec2i, A)] / {} = {
  [(v.x, v.y - 1), (v.x + 1, v.y), (v.x, v.y + 1), (v.x - 1, v.y)]
  .filter {v => grid.isInBound(v)} // filter out overlaps
  .map {v => (v, grid.get(v))}
}


def surroundingCells8[A](grid: Gamegrid[A] , v: Vec2i): List[A] / {} = {
  [(v.x, v.y - 1), (v.x + 1, v.y - 1),
   (v.x + 1, v.y), (v.x + 1, v.y + 1),
   (v.x, v.y + 1), (v.x - 1, v.y + 1),
   (v.x - 1, v.y), (v.x - 1, v.y - 1)]
  .filter {v => grid.isInBound(v)} // filter out overlaps
  .map {v => grid.get(v)}
}


def surroundingCells8WithIndices[A](grid: Gamegrid[A] ,v: Vec2i): List[(Vec2i, A)] / {} = {
  [(v.x, v.y - 1), (v.x + 1, v.y - 1),
   (v.x + 1, v.y), (v.x + 1, v.y + 1),
   (v.x, v.y + 1), (v.x - 1, v.y + 1),
   (v.x - 1, v.y), (v.x - 1, v.y - 1)]
  .filter {v => grid.isInBound(v)} // filter out overlaps
  .map {v => (v, grid.get(v))}
}


// TODO: Test
def addOntoIfInBound[A](v1: Vec2i, v2: Vec2i, grid: Gamegrid[A]): Vec2i / {} = {
  val v3 = v1 + v2
  if(grid.isInBound(v3)) {
    v3
  }
  else {
    v1
  }
}


// TODO: Test
def extendGridBy1[A](grid: Gamegrid[A], default: A): Gamegrid[A] / {} = {
  var new_grid = init(2 * grid.width + 1, 2 * grid.height + 1, default)

  grid.grid.foreachIndex {(i, a) =>
    val v = indexToCoords(i, grid.width)
    val new_x = (v.x * 2) + 1
    val new_y = (v.y * 2) + 1

    new_grid.set((new_x, new_y), a)
  }

  new_grid
}


// TODO: Test
def extendGridBy1Connecting[A](grid: Gamegrid[A], default: A, connections: List[(Vec2i, Vec2i, A)]): Gamegrid[A] / {} = {
  var new_grid = init(2 * grid.width + 1, 2 * grid.height + 1, default)

  // Placing old cells into new grid
  grid.grid.foreachIndex {(i, a) =>
    val v = indexToCoords(i, grid.width)
    val new_v = (v * 2) + (1,1) // transforming v into new grid

    new_grid.set(new_v, a)
  }

  // Placing connections
  connections.foreach {t =>

    val v1_t = (t.first * 2) + (1,1)
    val v2_t = (t.second * 2) + (1,1)

    if((v1_t - v2_t).length == 2.0) { // make sure only for cells with one cell in between
      val middle = ((v1_t.x + v2_t.x) / 2, (v1_t.y + v2_t.y) / 2)
      new_grid.set(middle, t.third)
    }
  }

  new_grid
}

// TODO: Test
def verticalCellsOf[A](grid: Gamegrid[A], x: Int): List[A] / {} = {
  (list::collect[Int] {range(0, grid.height)})
  .map {y => grid.get((x, y))}
}

// TODO: Test
def horizontalCellsOf[A](grid: Gamegrid[A], y: Int): List[A] / {} = {
  (list::collect[Int] {range(0, grid.width)})
  .map {x => grid.get((x, y))}
}

// TODO: Test
def verticalCellsExcluding[A](grid: Gamegrid[A], v: Vec2i): List[A] / {} = {
  (list::collect[Int] {range(0, v.y)}).append(
   list::collect[Int] {range(v.y + 1, grid.height)})
  .map {y => grid.get((v.x, y))}
}

// TODO: Test
def horizontalCellsExcluding[A](grid: Gamegrid[A], v: Vec2i): List[A] / {} = {
  (list::collect[Int] {range(0, v.x)}).append(
   list::collect[Int] {range(v.x + 1, grid.width)})
  .map {x => grid.get((x, v.y))}
}

def equals(a: Gamegrid[String], b: Gamegrid[String]): Bool / {} = {
  a.width == b.width && a.height == b.height && array::equals(a.grid, b.grid) {(s1, s2) => s1 == s2}
}

def equals(a: Gamegrid[Int], b: Gamegrid[Int]): Bool / {} = {
  a.width == b.width && a.height == b.height && array::equals(a.grid, b.grid) {(i1, i2) => i1 == i2}
}

def infixEq[A](a: Gamegrid[A], b: Gamegrid[A]): Bool / {} = {
  a.equals(b)
}

def copy[A](grid: Gamegrid[A]): Gamegrid[A] / {} = {
  Gamegrid(grid.width, grid.height, grid.grid.copy())
}


def testSuite(): Bool = suite("util/gamegrid") {

  def assertEqual(obtained: Gamegrid[String], expected: Gamegrid[String]) =
    assertEqual(obtained, expected) {(a, b) => a.equals(b) } { g => show(g) }

  def assertEqual(obtained: Gamegrid[Int], expected: Gamegrid[Int]) =
    assertEqual(obtained, expected) {(a, b) => a.equals(b) } { g => show(g) }

  test("init") {
    assertEqual(init(2,3,"O"),
                Gamegrid(2,3,fromList(["O", "O", "O", "O", "O", "O"])))
  }

  test("equalityInt") {
    assertEqual(Gamegrid(2, 2, fromList([1, 2, 3])),
                Gamegrid(2, 2, fromList([1, 2, 3])))
  }

  test("equalityString") {
    assertEqual(Gamegrid(2, 2, fromList(["A", "B", "C"])),
                Gamegrid(2, 2, fromList(["A", "B", "C"])))
  }

  test("notEquality") {
    assertFalse(equals(Gamegrid(2, 2, fromList(["A", "B", "C"])),
                       Gamegrid(2, 2, fromList(["C", "B", "A"]))))
  }

  test("initChessboard") {
    assertEqual(initWith(2,3) {v => if(coordsToIndex(v, 2).mod(2) == 0){"O"} else {"X"}},
                Gamegrid(2,3,fromList(["O", "X", "O", "X", "O", "X"])))
  }

  test("initAscending") {
    assertEqual(initWith(2,3) {v => coordsToIndex(v, 2)},
                Gamegrid(2,3,fromList([0, 1, 2, 3, 4, 5])))
  }

  test("set1") {
    var grid = init(2,3,"O")
    grid.set((0, 1), "X")
    assertEqual(grid,
                Gamegrid(2,3,fromList(["O", "O", "X", "O", "O", "O"])))
  }

  test("set2") {
    var grid = init(2,3,"O")
    grid.set((0, 1), "X")
    assertEqual(grid,
                Gamegrid(2,3,fromList(["O", "O", "X", "O", "O", "O"])))
  }

  test("set3") {
    var grid = init(3,3,"O")
    grid.set((0, 2), "X")
    assertEqual(grid,
                Gamegrid(3,3,fromList(["O", "O", "O", "O", "O", "O", "X", "O", "O"])))
  }

  test("setCopy") {
    var grid = init(3,3,"O")
    var new_grid = grid.setCopy((0, 0), "X")
    assertEqual(new_grid,
                Gamegrid(3,3,fromList(["X", "O", "O", "O", "O", "O", "O", "O", "O"])))
  }

  test("coordsToIndex") {
    assertEqual(coordsToIndex((1, 2), 4),
                9)
  }

  test("indexToCoords") {
    assertEqual(indexToCoords(9, 4),
                (1,2))
  }

  test("map") {
    val chessboard = initWith(2,3) {v => if(coordsToIndex(v, 2).mod(2) == 0){"O"} else {"X"}}
    assertEqual(chessboard.map {x => if (x == "O") {"X"} else {"O"}},
                Gamegrid(2,3,fromList(["X", "O", "X", "O", "X", "O"])))
  }

  test("mapWithIndex") {
    val grid = init(2, 3, "")
    assertEqual(grid.mapWithIndex {(v, a) => if (v.y == 0 || v.y == 2) {"X"} else {"O"}},
                Gamegrid(2,3,fromList(["X", "X", "O", "O", "X", "X"])))
  }

  test("isInBound1") {
    assertTrue(init(3,3, "").isInBound((0,0)))
  }

  test("isInBound2") {
    assertTrue(init(3,3, "").isInBound((2,2)))
  }

  test("isNotInBound1") {
    assertFalse(init(3,3, "").isInBound((3,3)))
  }

  test("isNotInBound2") {
    assertFalse(init(3,3, "").isInBound((-1,0)))
  }

  test("surroundingCells4") {
    val grid = initWith(3,3) {v => v}
    assertEqual(grid.surroundingCells4((1, 1)),
                [(1, 0), (2, 1), (1, 2), (0, 1)])
  }

  test("surroundingCells4WithIndices") {
    val grid = initWith(3,3) {v => v}
    assertEqual(grid.surroundingCells4WithIndices((1, 1)),
                [((1, 0), (1, 0)), ((2, 1), (2, 1)), ((1, 2), (1, 2)), ((0, 1), (0, 1))])
  }

  test("surroundingCells8") {
    val grid = initWith(3,3) {v => v}
    assertEqual(grid.surroundingCells8((1, 1)),
                [(1, 0), (2, 0), (2, 1), (2, 2),
                 (1, 2), (0, 2), (0, 1), (0, 0)])
  }

  test("surroundingCells8WithIndices") {
    val grid = initWith(3,3) {v => v}
    assertEqual(grid.surroundingCells8WithIndices((1, 1)),
                [((1, 0), (1, 0)), ((2, 0), (2, 0)), ((2, 1), (2, 1)), ((2, 2), (2, 2)),
                 ((1, 2), (1, 2)), ((0, 2), (0, 2)), ((0, 1), (0, 1)), ((0, 0), (0, 0))])
  }

  test("showString") {
    assertEqual(show(initWith(3,3) {v => if(coordsToIndex(v, 3).mod(2) == 0){"O"} else {"X"}}),
                "O X O \nX O X \nO X O ")
  }

  test("showInt") {
    assertEqual(show(initWith(3,3) {v => if(coordsToIndex(v, 3).mod(2) == 0){0} else {1}}),
                "0 1 0 \n1 0 1 \n0 1 0 ")
  }

  test("copy") {
    assertEqual(init(3, 3, "A").copy(),
                init(3, 3, "A"))
  }

  test("verticalCellsOf") {
    assertEqual(initWith(3, 3) {i => coordsToIndex(i, 3)}.verticalCellsOf(1),
                [1, 4, 7])
  }

  test("verticalCellsExcluding") {
    assertEqual(initWith(3, 3) {i => coordsToIndex(i, 3)}.verticalCellsExcluding((1, 1)),
                [1, 7])
  }

  test("horizontalCellsOf") {
    assertEqual(initWith(3, 3) {i => coordsToIndex(i, 3)}.horizontalCellsOf(1),
                [3, 4, 5])
  }

  test("horizontalCellsExcluding") {
    assertEqual(initWith(3, 3) {i => coordsToIndex(i, 3)}.horizontalCellsExcluding((1, 1)),
                [3, 5])
  }
}
