module src/util/gamegrid

import test
import src/util/vec2i

// Grid of values, defined top left to bottom right
record Gamegrid[A](width: Int, height: Int, grid:List[A])

def coordsToIndex(v: Vec2i, width: Int): Int = v.y * width + v.x
def indexToCoords(i: Int, width: Int): Vec2i / {} = (i.mod(width), i / width)

def set[A](grid: Gamegrid[A], v: Vec2i, a: A): Gamegrid[A] / {} = {
  with on[OutOfBounds].panic; // TODO: Maybe propagate
  val index = coordsToIndex((v.x, v.y), grid.width)
  val new_grid: List[A] = grid.grid.modifyAt(index) {a_ => a}
  Gamegrid(grid.width, grid.height, new_grid)
}

def get[A](grid: Gamegrid[A], v: Vec2i): A / {} = {
  with on[OutOfBounds].panic; // TODO: Maybe propagate
  val index = coordsToIndex(v, grid.width)
  grid.grid.get(index)
}

// Initialize Gamegrid with one value
def init[A](width: Int, height: Int, a: A): Gamegrid[A] / {} = {
  Gamegrid(width, height, fill(width * height, a))
}

// Initialize Gamegrid with individual values
def initWith[A](width: Int, height: Int) {f: Vec2i => A}: Gamegrid[A] / {} = {
  var grid: List[A] = []
  var index_x = 0
  var index_y = 0

  repeat(height) {
    repeat(width) {
      val a: A = f((index_x, index_y))
      grid = Cons(a,grid)
      index_x = index_x + 1
    }
    index_x = 0
    index_y = index_y + 1
  }

  grid = grid.reverse()

  Gamegrid(width, height, grid)
}


def show(grid: Gamegrid[String]): String / {} = {
  var index = 0
  var line = ""

  grid.grid.foreach {a =>
    if(index > grid.width - 1) {
      line = line ++ "\n"
      index = 0
    }

    line = line ++ a ++ " " // TODO: This might be wrong
    index = index + 1
  }
  line
}


def map[A, B](grid: Gamegrid[A]) {f: A => B}: Gamegrid[B] = {
  Gamegrid(grid.width, grid.height, grid.grid.map {f})
}

def mapWithIndex[A, B](grid: Gamegrid[A]) {f: (Vec2i, A) => B}: Gamegrid[B] / {} = {
  val new_grid = grid.grid.list::mapWithIndex[A, B]{(i, a) =>
                                                      val v = indexToCoords(i, grid.width) // transform index to coords
                                                      f(v, a) // and supply to coord-based function
                                                    }
  Gamegrid(grid.width, grid.height, new_grid)
}


def isInBound[A](grid: Gamegrid[A], v: Vec2i): Bool / {} = {
  (v.x >= 0 && v.x < grid.width &&
   v.y>= 0 && v.y < grid.height)
}


def surroundingCells4[A](grid: Gamegrid[A] , v: Vec2i): List[A] / {} = {
  [(v.x, v.y - 1), (v.x + 1, v.y), (v.x, v.y + 1), (v.x - 1, v.y)]
  .filter {v => grid.isInBound(v)} // filter out overlaps
  .map {v => grid.get(v)}
}


def surroundingCells4WithIndices[A](grid: Gamegrid[A] , v: Vec2i): List[(Vec2i, A)] / {} = {
  [(v.x, v.y - 1), (v.x + 1, v.y), (v.x, v.y + 1), (v.x - 1, v.y)]
  .filter {v => grid.isInBound(v)} // filter out overlaps
  .map {v => (v, grid.get(v))}
}


def surroundingCells8[A](grid: Gamegrid[A] , v: Vec2i): List[A] / {} = {
  [(v.x, v.y - 1), (v.x + 1, v.y - 1),
   (v.x + 1, v.y), (v.x + 1, v.y + 1),
   (v.x, v.y + 1), (v.x - 1, v.y + 1),
   (v.x - 1, v.y), (v.x - 1, v.y - 1)]
  .filter {v => grid.isInBound(v)} // filter out overlaps
  .map {v => grid.get(v)}
}


def surroundingCells8WithIndices[A](grid: Gamegrid[A] ,v: Vec2i): List[(Vec2i, A)] / {} = {
  [(v.x, v.y - 1), (v.x + 1, v.y - 1),
   (v.x + 1, v.y), (v.x + 1, v.y + 1),
   (v.x, v.y + 1), (v.x - 1, v.y + 1),
   (v.x - 1, v.y), (v.x - 1, v.y - 1)]
  .filter {v => grid.isInBound(v)} // filter out overlaps
  .map {v => (v, grid.get(v))}
}


def testSuite(): Bool = suite("util/gamegrid") {

  test("init") {
    assertEqual(init(2,3,"O"),
                Gamegrid(2,3,["O", "O", "O", "O", "O", "O"]))
  }

  test("initChessboard") {
    assertEqual(initWith(2,3) {v => if(coordsToIndex(v, 2).mod(2) == 0){"O"} else {"X"}},
                Gamegrid(2,3,["O", "X", "O", "X", "O", "X"]))
  }

  test("initAscending") {
    assertEqual(initWith(2,3) {v => coordsToIndex(v, 2)},
                Gamegrid(2,3,[0, 1, 2, 3, 4, 5]))
  }

  test("set1") {
    assertEqual(init(2,3,"O").set((0, 1), "X"),
                Gamegrid(2,3,["O", "O", "X", "O", "O", "O"]))
  }

  test("set2") {
    assertEqual(init(2,3,"O").set((1, 0), "X"),
                Gamegrid(2,3,["O", "X", "O", "O", "O", "O"]))
  }

  test("set3") {
    assertEqual(init(3,3,"O").set((0, 2), "X"),
                Gamegrid(3,3,["O", "O", "O", "O", "O", "O", "X", "O", "O"]))
  }

  test("coordsToIndex") {
    assertEqual(coordsToIndex((1, 2), 4),
                9)
  }

  test("indexToCoords") {
    assertEqual(indexToCoords(9, 4),
                (1,2))
  }

  test("map") {
    val chessboard = initWith(2,3) {v => if(coordsToIndex(v, 2).mod(2) == 0){"O"} else {"X"}}
    assertEqual(chessboard.map {x => if (x == "O") {"X"} else {"O"}},
                Gamegrid(2,3,["X", "O", "X", "O", "X", "O"]))
  }

  test("mapWithIndex") {
    val grid = init(2, 3, "")
    assertEqual(grid.mapWithIndex {(v, a) => if (v.y == 0 || v.y == 2) {"X"} else {"O"}},
                Gamegrid(2,3,["X", "X", "O", "O", "X", "X"]))
  }

  test("show") {
    assertEqual(show(initWith(3,3) {v => if(coordsToIndex(v, 3).mod(2) == 0){"O"} else {"X"}}),
                "O X O \nX O X \nO X O ")
  }
}
