module src/util/gamegrid

import test

// Grid of values, defined top left to bottom right
record Gamegrid[A](width: Int, height: Int, grid:List[A])

def coordsToIndex(x: Int, y: Int, width: Int): Int = y * width + x
def indexToCoords(i: Int, width: Int): (Int, Int) / {} = (i.mod(width), i / width)

def set[A](grid: Gamegrid[A], x: Int, y: Int, a: A): Gamegrid[A] / {} = {
  with on[OutOfBounds].panic; // TODO: Maybe propagate
  val index = coordsToIndex(x, y, grid.width)
  val new_grid: List[A] = grid.grid.modifyAt(index) {a_ => a}
  Gamegrid(grid.width, grid.height, new_grid)
}

def get[A](grid: Gamegrid[A], x: Int, y: Int): A / {} = {
  with on[OutOfBounds].panic; // TODO: Maybe propagate
  val index = coordsToIndex(x, y, grid.width)
  grid.grid.get(index)
}

// Initialize Gamegrid with one value
def init[A](width: Int, height: Int, a: A): Gamegrid[A] / {} = {
  Gamegrid(width, height, fill(width * height, a))
}

// Initialize Gamegrid with individual values
def initWith[A](width: Int, height: Int) {f: Tuple2[Int, Int] => A}: Gamegrid[A] / {} = {
  var grid: List[A] = []
  var index_x = 0
  var index_y = 0

  repeat(height) {
    repeat(width) {
      val a: A = f((index_x, index_y))
      grid = Cons(a,grid)
      index_x = index_x + 1
    }
    index_x = 0
    index_y = index_y + 1
  }

  grid = grid.reverse()

  Gamegrid(width, height, grid)
}


def show(grid: Gamegrid[String]): String / {} = {
  var index = 0
  var line = ""

  grid.grid.foreach {a =>
    if(index > grid.width - 1) {
      line = line ++ "\n"
      index = 0
    }

    line = line ++ a ++ " " // TODO: This might be wrong
    index = index + 1
  }
  line
}


def map[A, B](grid: Gamegrid[A]) {f: A => B}: Gamegrid[B] = {
  Gamegrid(grid.width, grid.height, grid.grid.map {f})
}

def mapWithIndex[A, B](grid: Gamegrid[A]) {f: (Int, Int, A) => B}: Gamegrid[B] / {} = {
  val new_grid = grid.grid.list::mapWithIndex[A, B]{(i, a) =>
                                                      val t = indexToCoords(i, grid.width) // transform index to coords
                                                      f(t.first, t.second, a) // and supply to coord-based function
                                                    }
  Gamegrid(grid.width, grid.height, new_grid)
}


def isInBound[A](grid: Gamegrid[A], x: Int, y: Int): Bool / {} = {
  (x >= 0 && x < grid.width &&
   y>= 0 && y < grid.height)
}


def surroundingCells4[A](grid: Gamegrid[A] , x: Int, y: Int): List[A] / {} = {
  [(x, y - 1), (x + 1, y), (x, y + 1), (x - 1, y)]
  .filter {t => grid.isInBound(t.first, t.second)} // filter out overlaps
  .map {t => grid.get(t.first, t.second)}
}


def surroundingCells4WithIndices[A](grid: Gamegrid[A] , x: Int, y: Int): List[(Int, Int, A)] / {} = {
  [(x, y - 1), (x + 1, y), (x, y + 1), (x - 1, y)]
  .filter {t => grid.isInBound(t.first, t.second)} // filter out overlaps
  .map {t => (t.first, t.second, grid.get(t.first, t.second))}
}


def surroundingCells8[A](grid: Gamegrid[A] , x: Int, y: Int): List[A] / {} = {
  [(x, y - 1), (x + 1, y - 1),
   (x + 1, y), (x + 1, y + 1),
   (x, y + 1), (x - 1, y + 1),
   (x - 1, y), (x - 1, y - 1)]
  .filter {t => grid.isInBound(t.first, t.second)} // filter out overlaps
  .map {t => grid.get(t.first, t.second)}
}


def surroundingCells8WithIndices[A](grid: Gamegrid[A] , x: Int, y: Int): List[(Int, Int, A)] / {} = {
  [(x, y - 1), (x + 1, y - 1),
   (x + 1, y), (x + 1, y + 1),
   (x, y + 1), (x - 1, y + 1),
   (x - 1, y), (x - 1, y - 1)]
  .filter {t => grid.isInBound(t.first, t.second)} // filter out overlaps
  .map {t => (t.first, t.second, grid.get(t.first, t.second))}
}


def testSuite(): Bool = suite("util/gamegrid") {

  test("init") {
    assertEqual(init(2,3,"O"),
                Gamegrid(2,3,["O", "O", "O", "O", "O", "O"]))
  }

  test("initChessboard") {
    assertEqual(initWith(2,3) {t => if(coordsToIndex(t.first, t.second, 2).mod(2) == 0){"O"} else {"X"}},
                Gamegrid(2,3,["O", "X", "O", "X", "O", "X"]))
  }

  test("initAscending") {
    assertEqual(initWith(2,3) {t => coordsToIndex(t.first, t.second, 2)},
                Gamegrid(2,3,[0, 1, 2, 3, 4, 5]))
  }

  test("set1") {
    assertEqual(init(2,3,"O").set(0, 1, "X"),
                Gamegrid(2,3,["O", "O", "X", "O", "O", "O"]))
  }

  test("set2") {
    assertEqual(init(2,3,"O").set(1, 0, "X"),
                Gamegrid(2,3,["O", "X", "O", "O", "O", "O"]))
  }

  test("set3") {
    assertEqual(init(3,3,"O").set(0, 2, "X"),
                Gamegrid(3,3,["O", "O", "O", "O", "O", "O", "X", "O", "O"]))
  }

  test("coordsToIndex") {
    assertEqual(coordsToIndex(1, 2, 4),
                9)
  }

  test("indexToCoords") {
    assertEqual(indexToCoords(9, 4),
                (1,2))
  }

  test("map") {
    val chessboard = initWith(2,3) {t => if(coordsToIndex(t.first, t.second, 2).mod(2) == 0){"O"} else {"X"}}
    assertEqual(chessboard.map {x => if (x == "O") {"X"} else {"O"}},
                Gamegrid(2,3,["X", "O", "X", "O", "X", "O"]))
  }

  test("mapWithIndex") {
    val grid = init(2, 3, "")
    assertEqual(grid.mapWithIndex {(x, y, a) => if (y == 0 || y == 2) {"X"} else {"O"}},
                Gamegrid(2,3,["X", "X", "O", "O", "X", "X"]))
  }

  test("show") {
    assertEqual(show(initWith(3,3) {t => if(coordsToIndex(t.first, t.second, 3).mod(2) == 0){"O"} else {"X"}}),
                "O X O \nX O X \nO X O ")
  }
}
