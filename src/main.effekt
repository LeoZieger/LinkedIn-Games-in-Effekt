import tty
import io/console
import bench
import random
import control

import src/util/gamestate
import src/util/gamegrid
import src/games/queens
import src/games/zip


def playinterface() {gameloop: () => Unit / {Gamestate}} = {
  var last_grid = init(1, 1, "") // Dummy value

  with console;
  try {
    gameloop()
  } with Gamestate {
      def getUserInput(allowed) = {
        println(show(allowed))

        var ret = ""

        loop() {{l: Label} =>
          val input = do readLine()

          if (allowed.map{o => o.key}.contains(input) {(a, b) => a == b}) {
            ret = input
            l.break()
          }
          else {
            println(Screen::clear()) // In case of invalid input, show the screen again
            println(show(last_grid))
            println(show(allowed)) // + Input Options
          }
        }
        resume(ret)
      }

      def updateGrid(grid) = {
        last_grid = grid
        println(Screen::clear())
        println(show(last_grid))
        resume(())
      }

      def gameWon(msg) = {
        println(msg)
      }
  }
}

def main(): Unit =  {
  with playinterface;
  with minstd(timestamp());
  // play_queens()
  zip::playGame(4, 0.3, 0.5)
}


// TODO: Rewirte same as zip
def play_queens(): Unit / {random}= {
  with on[RuntimeError].panic() // TODO: Do I need this?
  val b = queens::generateGame(4).hideQueens()
  with playinterface;
  gameloop(b)
}
